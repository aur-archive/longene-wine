diff -urN wine-1.0/configure wine-1.0-uk/configure
--- wine-1.0/configure	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/configure	2009-08-18 16:11:13.000000000 +0800
@@ -574,7 +574,7 @@
 # Identity of this package.
 PACKAGE_NAME='Wine'
 PACKAGE_TARNAME='wine'
-PACKAGE_VERSION='1.0'
+PACKAGE_VERSION='1.0-uk'
 PACKAGE_STRING='Wine 1.0'
 PACKAGE_BUGREPORT='wine-devel@winehq.org'
 
diff -urN wine-1.0/dlls/comdlg32/cdlg_Cn.rc wine-1.0-uk/dlls/comdlg32/cdlg_Cn.rc
--- wine-1.0/dlls/comdlg32/cdlg_Cn.rc	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/comdlg32/cdlg_Cn.rc	2009-08-18 16:11:13.000000000 +0800
@@ -443,4 +443,14 @@
     PD32_PRINTER_STATUS_POWER_SAVE        "Power safe mode; "
 }
 
+/* Unified Kernel: add for Chinese characters display */
+STRINGTABLE DISCARDABLE
+{
+    IDS_FONT_SIZE   "Select a font size between %d and %d points."
+    IDS_SAVE_BUTTON "保存(&s)"
+    IDS_SAVE_IN     "保存在(&i)"
+    IDS_SAVE        "保存"
+    IDS_SAVE_AS     "另存为"
+    IDS_OPEN_FILE   "打开文件"
+}
 #pragma code_page(default)
diff -urN wine-1.0/dlls/comdlg32/filedlg.c wine-1.0-uk/dlls/comdlg32/filedlg.c
--- wine-1.0/dlls/comdlg32/filedlg.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/comdlg32/filedlg.c	2009-08-18 16:11:13.000000000 +0800
@@ -3840,6 +3840,14 @@
 {
     BOOL win16look = FALSE;
 
+#ifdef UNIFIED_KERNEL	
+    char class_name[MAX_PATH]; 
+    char app_name[] = "TApplication";
+    GetClassNameA(ofn->hwndOwner, class_name, sizeof(class_name) );
+
+    if (!lstrcmpA(class_name, app_name) && ofn->hwndOwner != GetActiveWindow())
+        ofn->hwndOwner = GetActiveWindow();
+#endif
     TRACE("flags %08x\n", ofn->Flags);
 
     /* OFN_FILEMUSTEXIST implies OFN_PATHMUSTEXIST */
@@ -3870,6 +3878,14 @@
 {
     BOOL win16look = FALSE;
 
+#ifdef UNIFIED_KERNEL	
+    WCHAR class_name[MAX_PATH]; 
+    WCHAR app_name[] = {'T', 'A','p','p','l','i','c','a','t','i','o','n', 0};
+    GetClassNameW(ofn->hwndOwner, class_name, sizeof(class_name) );
+
+    if (!lstrcmpW(class_name, app_name) && ofn->hwndOwner != GetActiveWindow())
+        ofn->hwndOwner = GetActiveWindow();
+#endif
     TRACE("flags %08x\n", ofn->Flags);
 
     /* OFN_FILEMUSTEXIST implies OFN_PATHMUSTEXIST */
@@ -3901,6 +3917,14 @@
 {
     BOOL win16look = FALSE;
 
+#ifdef UNIFIED_KERNEL	
+    char class_name[MAX_PATH]; 
+    char app_name[] = "TApplication";
+    GetClassNameA(ofn->hwndOwner, class_name, sizeof(class_name) );
+
+    if (!lstrcmpA(class_name, app_name) && ofn->hwndOwner != GetActiveWindow())
+        ofn->hwndOwner = GetActiveWindow();
+#endif
     if (ofn->Flags & (OFN_ALLOWMULTISELECT|OFN_ENABLEHOOK|OFN_ENABLETEMPLATE))
         win16look = (ofn->Flags & OFN_EXPLORER) ? FALSE : TRUE;
 
@@ -3925,6 +3949,14 @@
 {
     BOOL win16look = FALSE;
 
+#ifdef UNIFIED_KERNEL	
+    WCHAR class_name[MAX_PATH]; 
+    WCHAR app_name[] = {'T', 'A','p','p','l','i','c','a','t','i','o','n', 0};
+    GetClassNameW(ofn->hwndOwner, class_name, sizeof(class_name) );
+
+    if (!lstrcmpW(class_name, app_name) && ofn->hwndOwner != GetActiveWindow())
+        ofn->hwndOwner = GetActiveWindow();
+#endif
     if (ofn->Flags & (OFN_ALLOWMULTISELECT|OFN_ENABLEHOOK|OFN_ENABLETEMPLATE))
         win16look = (ofn->Flags & OFN_EXPLORER) ? FALSE : TRUE;
 
diff -urN wine-1.0/dlls/gdi32/font.c wine-1.0-uk/dlls/gdi32/font.c
--- wine-1.0/dlls/gdi32/font.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/gdi32/font.c	2009-08-18 16:11:13.000000000 +0800
@@ -35,6 +35,9 @@
 #include "gdi_private.h"
 #include "wine/unicode.h"
 #include "wine/debug.h"
+#ifdef UNIFIED_KERNEL
+#include <wchar.h>
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(font);
 
@@ -1563,7 +1566,11 @@
     LPINT lpDxW = NULL;
 
     if (flags & ETO_GLYPH_INDEX)
+#ifdef UNIFIED_KERNEL
+        return ExtTextOutW( hdc, x, y, flags, lprect, (LPWSTR)str, count, lpDx );
+#else
         return ExtTextOutW( hdc, x, y, flags, lprect, (LPCWSTR)str, count, lpDx );
+#endif
 
     p = FONT_mbtowc(hdc, str, count, &wlen, &codepage);
 
@@ -1620,8 +1627,13 @@
  *    Success: TRUE
  *    Failure: FALSE
  */
+#ifndef UNIFIED_KERNEL
 BOOL WINAPI ExtTextOutW( HDC hdc, INT x, INT y, UINT flags,
                          const RECT *lprect, LPCWSTR str, UINT count, const INT *lpDx )
+#else
+BOOL WINAPI ExtTextOutW( HDC hdc, INT x, INT y, UINT flags,
+                         const RECT *lprect, LPWSTR str, UINT count, const INT *lpDx )
+#endif
 {
     BOOL ret = FALSE;
     LPWSTR reordered_str = (LPWSTR)str;
@@ -1640,6 +1652,102 @@
     DC * dc = get_dc_ptr( hdc );
     INT breakRem;
 
+#ifdef UNIFIED_KERNEL
+    HFONT hfOld = 0;
+    double arc = 0;
+    BOOL bAtFont;
+    UINT prev_align = align;
+    int i;
+
+    if (!dc) return FALSE;
+
+    if ((INT)count == -1)
+        count = strlenW(str);
+
+    if (align == TA_BASELINE) {
+        TEXTMETRICW tmw;
+        LOGFONTW lf;
+
+        GetTextMetricsW(hdc, &tmw);
+
+        lfCloneFromDC(dc, &lf);
+        arc = lf.lfOrientation * M_PI / 1800;
+
+        x -= sin(arc) * tmw.tmAscent;
+        y -= cos(arc) * tmw.tmAscent;
+        align = TA_LEFT | TA_TOP;
+    }
+
+    if (font_is_bold(dc->gdiFont)) {
+        if (GetMapMode(hdc) == MM_TEXT)
+            flags |= ETO_BOLD_FLAG1;
+        else
+            flags |= ETO_BOLD_FLAG2;
+    }
+
+    bAtFont = font_is_rotate(dc->gdiFont);
+
+    if( str!=NULL && count!=0 && bAtFont) {
+        if (isalnum((int)str[0]))
+        if((str[0] >= 0x0030 && str[0] <= 0x0039) /* number */
+                || (str[0] >= 0x0041 && str[0] <= 0x005A) /* case letter */
+                || (str[0] >= 0x0061 && str[0] <= 0x007A)) /* letter */
+            bAtFont = FALSE;
+    }
+
+    if(bAtFont) {
+        LOGFONTW lf;
+        HFONT hf;
+        double arc2 = (lf.lfEscapement - 900) * M_PI / 1800;
+
+        if (!(lf.lfEscapement - 900) % 900)
+            flags |= ETO_ROTATE;
+
+        for(i = 0; i < count; i++) {
+            switch(str[i]) {
+                case 0x201c: /* "(left) */
+                    str[i] = 0xfe43;
+                    break;
+                case 0x201d: /* "(right) */
+                    str[i] = 0xfe44;
+                    break;
+                case 0x2018: /* '(left) */
+                    str[i] = 0xfe41;
+                    break;
+                case 0x2019: /*'(right) */
+                    str[i] = 0xfe42;
+                    break;
+                case 0x300a: /* << */
+                    str[i] = 0xfe3d;
+                    break;
+                case 0x300b: /* >> */
+                    str[i] = 0xfe3e;
+                    break;
+                default:
+                    break;
+            }
+        }
+        lfCloneFromDC(dc, &lf);
+
+        hf = CreateFontIndirectW(&lf);
+        hfOld = SelectObject(hdc, hf);
+        GetRotate(dc, lf);
+
+        switch (align) {
+            case TA_TOP:
+                {
+                    TEXTMETRICW tm;
+
+                    GetTextMetricsW(hdc, &tm);
+                    x += sin(arc2) * tm.tmHeight;
+                    y += cos(arc2) * tm.tmHeight;
+                    break;
+                }
+            default:
+                break;
+        }
+    }
+#endif
     if (!dc) return FALSE;
 
     breakRem = dc->breakRem;
@@ -2067,6 +2175,12 @@
         }
     }
 
+#ifdef UNIFIED_KERNEL
+    if (hfOld)
+        SelectObject(hdc, hfOld);
+    SetTextAlign(hdc, prev_align);
+#endif
+
     return ret;
 }
 
@@ -2085,7 +2199,11 @@
  */
 BOOL WINAPI TextOutW(HDC hdc, INT x, INT y, LPCWSTR str, INT count)
 {
+#ifdef UNIFIED_KERNEL
+    return ExtTextOutW( hdc, x, y, 0, NULL, (LPWSTR)str, count, NULL );
+#else
     return ExtTextOutW( hdc, x, y, 0, NULL, str, count, NULL );
+#endif
 }
 
 
@@ -2116,7 +2234,12 @@
 BOOL WINAPI PolyTextOutW( HDC hdc, const POLYTEXTW *pptxt, INT cStrings )
 {
     for (; cStrings>0; cStrings--, pptxt++)
+#ifdef UNIFIED_KERNEL
+        if (!ExtTextOutW( hdc, pptxt->x, pptxt->y, pptxt->uiFlags, &pptxt->rcl,
+                    (LPWSTR)pptxt->lpstr, pptxt->n, pptxt->pdx ))
+#else
         if (!ExtTextOutW( hdc, pptxt->x, pptxt->y, pptxt->uiFlags, &pptxt->rcl, pptxt->lpstr, pptxt->n, pptxt->pdx ))
+#endif
             return FALSE;
     return TRUE;
 }
@@ -2348,9 +2471,31 @@
 
     if(!dc) return GDI_ERROR;
 
+#ifdef UNIFIED_KERNEL
+    if (dc->gdiFont && font_is_italic(dc->gdiFont)) {
+        MAT2 mat;
+        memset(&mat, 0, sizeof(MAT2));
+
+        mat.eM11.value = 1;
+        mat.eM12.value = 0;
+        mat.eM21.value = 0;
+        mat.eM22.value = 1;
+
+        if (lpmat2)
+            ret = WineEngGetGlyphOutline(dc->gdiFont, uChar, fuFormat, lpgm,
+                    cbBuffer, lpBuffer, lpmat2);
+        else
+            ret = WineEngGetGlyphOutline(dc->gdiFont, uChar, fuFormat, lpgm,
+                    cbBuffer, lpBuffer, &mat);
+    }
+    else if(dc->gdiFont)
+        ret = WineEngGetGlyphOutline(dc->gdiFont, uChar, fuFormat, lpgm,
+                cbBuffer, lpBuffer, lpmat2);
+#else
     if(dc->gdiFont)
       ret = WineEngGetGlyphOutline(dc->gdiFont, uChar, fuFormat, lpgm,
 				   cbBuffer, lpBuffer, lpmat2);
+#endif
     else
       ret = GDI_ERROR;
 
diff -urN wine-1.0/dlls/gdi32/freetype.c wine-1.0-uk/dlls/gdi32/freetype.c
--- wine-1.0/dlls/gdi32/freetype.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/gdi32/freetype.c	2009-08-19 13:44:51.000000000 +0800
@@ -36,6 +36,9 @@
 #include <dirent.h>
 #include <stdio.h>
 #include <assert.h>
+#ifdef UNIFIED_KERNEL
+#include <wchar.h>
+#endif
 
 #ifdef HAVE_CARBON_CARBON_H
 #define LoadResource __carbon_LoadResource
@@ -163,7 +166,11 @@
 MAKE_FUNCPTR(FT_Init_FreeType);
 MAKE_FUNCPTR(FT_Load_Glyph);
 MAKE_FUNCPTR(FT_Matrix_Multiply);
+#ifdef FT_MULFIX_INLINED
+#define pFT_MulFix FT_MULFIX_INLINED
+#else
 MAKE_FUNCPTR(FT_MulFix);
+#endif
 MAKE_FUNCPTR(FT_New_Face);
 MAKE_FUNCPTR(FT_New_Memory_Face);
 MAKE_FUNCPTR(FT_Outline_Get_Bitmap);
@@ -323,6 +330,9 @@
     int codepage;
     BOOL fake_italic;
     BOOL fake_bold;
+#ifdef UNIFIED_KERNEL
+    BOOL rotate;
+#endif
     BYTE underline;
     BYTE strikeout;
     INT orientation;
@@ -470,6 +480,66 @@
 
 static BOOL get_glyph_index_linked(GdiFont *font, UINT c, GdiFont **linked_font, FT_UInt *glyph);
 
+#ifdef UNIFIED_KERNEL
+inline BOOL font_is_rotate(GdiFont *font)
+{
+    return font->rotate;
+}
+
+inline BOOL font_is_italic(GdiFont *font)
+{
+    return font-> charset && font->fake_italic;
+}
+
+inline BOOL font_is_bold(GdiFont *font)
+{
+    return font->fake_bold && font->charset;
+}
+
+extern void lfCloneFromDC(DC *dc, LOGFONTW *lf)
+{
+    LOGFONTW *sourlf = &(((dc->gdiFont)->font_desc).lf);
+    if(sourlf->lfFaceName == NULL)
+        return;
+    lf->lfHeight         = sourlf->lfHeight;
+    lf->lfWidth          = sourlf->lfWidth;
+    lf->lfEscapement     = sourlf->lfEscapement + 900;
+    lf->lfOrientation    = sourlf->lfOrientation;
+    lf->lfWeight         = sourlf->lfWeight;
+    lf->lfItalic         = sourlf->lfItalic;
+    lf->lfUnderline      = sourlf->lfUnderline;
+    lf->lfStrikeOut      = sourlf->lfStrikeOut;
+    lf->lfCharSet        = sourlf->lfCharSet; 
+    lf->lfOutPrecision   = sourlf->lfOutPrecision;
+    lf->lfClipPrecision  = sourlf->lfClipPrecision;
+    lf->lfQuality        = lf->lfQuality;
+    lf->lfPitchAndFamily = sourlf->lfPitchAndFamily;
+    if(sourlf->lfFaceName[0] != '\0' && sourlf->lfFaceName[0] == 0x0040)/* '@' unicode */
+    {
+        int i=1;
+        while(sourlf->lfFaceName[i])
+        {
+            lf->lfFaceName[i] = sourlf->lfFaceName[i];
+            i++;
+        }
+        lf->lfFaceName[i] = 0x0;
+    }
+    else
+    {
+        strcpyW(lf->lfFaceName, sourlf->lfFaceName);	
+    }
+#if 0
+    FindEnFontName(lf->lfFaceName);
+#endif
+    TRACE("CloneFontConverted: %s\n", debugstr_w(lf->lfFaceName));
+}
+
+extern void GetRotate(DC *dc, LOGFONTW lf)
+{
+    dc->gdiFont->font_desc.lf.lfEscapement = lf.lfEscapement;
+    dc->gdiFont->font_desc.lf.lfOrientation = lf.lfOrientation;
+}
+#endif
 /****************************************
  *   Notes on .fon files
  *
@@ -2343,7 +2413,9 @@
     LOAD_FUNCPTR(FT_Init_FreeType)
     LOAD_FUNCPTR(FT_Load_Glyph)
     LOAD_FUNCPTR(FT_Matrix_Multiply)
+#ifndef FT_MULFIX_INLINED
     LOAD_FUNCPTR(FT_MulFix)
+#endif
     LOAD_FUNCPTR(FT_New_Face)
     LOAD_FUNCPTR(FT_New_Memory_Face)
     LOAD_FUNCPTR(FT_Outline_Get_Bitmap)
@@ -3200,6 +3272,10 @@
 
     ret = alloc_font();
 
+#ifdef UNIFIED_KERNEL
+	if (lf.lfFaceName[0] != '\0' && lf.lfFaceName[0] == 0x0040)
+		ret->rotate = TRUE;
+#endif
      memcpy(&ret->font_desc.matrix, &dc->xformWorld2Vport, sizeof(FMAT2));
      ret->font_desc.lf = lf;
      ret->font_desc.can_use_bitmap = can_use_bitmap;
@@ -3217,17 +3293,24 @@
     if(!strcmpiW(lf.lfFaceName, SymbolW))
         lf.lfCharSet = SYMBOL_CHARSET;
 
+#ifndef UNIFIED_KERNEL 
     if(!TranslateCharsetInfo((DWORD*)(INT_PTR)lf.lfCharSet, &csi, TCI_SRCCHARSET)) {
-        switch(lf.lfCharSet) {
-	case DEFAULT_CHARSET:
-	    csi.fs.fsCsb[0] = 0;
-	    break;
-	default:
-	    FIXME("Untranslated charset %d\n", lf.lfCharSet);
-	    csi.fs.fsCsb[0] = 0;
-	    break;
-	}
-    }
+#else
+	    if( lf.lfCharSet == DEFAULT_CHARSET || lf.lfCharSet == ANSI_CHARSET) {
+		    if(!TranslateCharsetInfo((DWORD*)(INT_PTR)lf.lfCharSet, &csi, TCI_SRCCODEPAGE))
+			    csi.fs.fsCsb[0] = 0;
+	    } else if(!TranslateCharsetInfo((DWORD*)(INT)lf.lfCharSet, &csi, TCI_SRCCHARSET)) {
+#endif
+		    switch(lf.lfCharSet) {
+			    case DEFAULT_CHARSET:
+				    csi.fs.fsCsb[0] = 0;
+				    break;
+			    default:
+				    FIXME("Untranslated charset %d\n", lf.lfCharSet);
+				    csi.fs.fsCsb[0] = 0;
+				    break;
+		    }
+	    }
 
     family = NULL;
     if(lf.lfFaceName[0] != '\0') {
@@ -4262,10 +4345,20 @@
     if (font->fake_italic) {
         FT_Matrix slantMat;
         
+#ifndef UNIFIED_KERNEL
         slantMat.xx = (1 << 16);
         slantMat.xy = ((1 << 16) >> 2);
         slantMat.yx = 0;
         slantMat.yy = (1 << 16);
+#else
+        double arc = (font->font_desc.lf.lfEscapement - font->font_desc.lf.lfOrientation) * M_PI / 1800;
+        double angle = 201 * M_PI / 1800;
+
+        slantMat.xx = (1 << 16);
+        slantMat.xy = abs(cos(arc) * sin(angle) * 0x10000L);
+        slantMat.yx = - abs(sin(arc) * sin(angle) * 0x10000L);
+        slantMat.yy = (1 << 16);
+#endif
         pFT_Matrix_Multiply(&slantMat, &transMat);
         needsTransform = TRUE;
     }
diff -urN wine-1.0/dlls/gdi32/gdi_private.h wine-1.0-uk/dlls/gdi32/gdi_private.h
--- wine-1.0/dlls/gdi32/gdi_private.h	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/gdi32/gdi_private.h	2009-08-18 16:11:13.000000000 +0800
@@ -515,6 +515,14 @@
 /* Undocumented value for DIB's iUsage: Indicates a mono DIB w/o pal entries */
 #define DIB_PAL_MONO 2
 
+#ifdef UNIFIED_KERNEL
+extern BOOL font_is_rotate(GdiFont *font);
+extern BOOL font_is_italic(GdiFont *font);
+extern BOOL font_is_bold(GdiFont *font);
+extern void lfCloneFromDC(DC *dc, LOGFONTW *lf);
+extern void log_hdc(HDC hdc, DC *dc);
+extern void GetRotate(DC *dc, LOGFONTW lf);
+#endif
 BOOL WINAPI FontIsLinked(HDC);
 
 #endif /* __WINE_GDI_PRIVATE_H */
diff -urN wine-1.0/dlls/gdi32/metafile.c wine-1.0-uk/dlls/gdi32/metafile.c
--- wine-1.0/dlls/gdi32/metafile.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/gdi32/metafile.c	2009-08-18 16:11:13.000000000 +0800
@@ -913,7 +913,11 @@
     case META_DIBSTRETCHBLT:
       {
         LPBITMAPINFO info = (LPBITMAPINFO) &(mr->rdParm[10]);
+#ifdef UNIFIED_KERNEL
+        LPSTR bits = (LPSTR)info + bitmap_info_size( info, DIB_RGB_COLORS);
+#else
         LPSTR bits = (LPSTR)info + bitmap_info_size( info, mr->rdParm[2] );
+#endif
         StretchDIBits( hdc, (SHORT)mr->rdParm[9], (SHORT)mr->rdParm[8], (SHORT)mr->rdParm[7],
                        (SHORT)mr->rdParm[6], (SHORT)mr->rdParm[5], (SHORT)mr->rdParm[4],
                        (SHORT)mr->rdParm[3], (SHORT)mr->rdParm[2], bits, info,
diff -urN wine-1.0/dlls/kernel32/debugger.c wine-1.0-uk/dlls/kernel32/debugger.c
--- wine-1.0/dlls/kernel32/debugger.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/kernel32/debugger.c	2009-08-19 10:13:55.000000000 +0800
@@ -27,6 +27,9 @@
 #include "kernel_private.h"
 #include "kernel16_private.h"
 #include "wine/debug.h"
+#ifdef UNIFIED_KERNEL
+#include "handle.h"
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(debugstr);
 
@@ -325,6 +328,11 @@
 
     TRACE("(%p)\n", hProc);
 
+#ifdef UNIFIED_KERNEL
+    struct handle_pair* pair = search_handle_pair(hProc);
+    if (pair)
+        hProc= pair->wine_handle;
+#endif
     SERVER_START_REQ( debug_break )
     {
         req->handle = hProc;
diff -urN wine-1.0/dlls/kernel32/dosmem.c wine-1.0-uk/dlls/kernel32/dosmem.c
--- wine-1.0/dlls/kernel32/dosmem.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/kernel32/dosmem.c	2009-08-19 10:13:55.000000000 +0800
@@ -163,6 +163,7 @@
     void *addr = NULL;
     void * const low_64k = (void *)DOSMEM_64KB;
 
+#ifndef UNIFIED_KERNEL
     /* check without the first 64K */
 
     if (wine_mmap_is_in_reserved_area( low_64k, DOSMEM_SIZE - DOSMEM_64KB ) != 1)
@@ -207,6 +208,7 @@
 
     /* inform the memory manager that there is a mapping here, but don't commit yet */
     VirtualAlloc( addr, size, MEM_RESERVE | MEM_SYSTEM, PAGE_NOACCESS );
+#endif
     DOSMEM_protect = DOSMEM_64KB;
     DOSMEM_dosmem = NULL;
     return (char *)0xf0000;  /* store sysmem in high addresses for now */
diff -urN wine-1.0/dlls/kernel32/process.c wine-1.0-uk/dlls/kernel32/process.c
--- wine-1.0/dlls/kernel32/process.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/kernel32/process.c	2009-08-19 10:22:11.000000000 +0800
@@ -52,6 +52,10 @@
 #include "wine/unicode.h"
 #include "wine/debug.h"
 
+#ifdef UNIFIED_KERNEL
+#include "handle.h"
+#endif
+
 WINE_DEFAULT_DEBUG_CHANNEL(process);
 WINE_DECLARE_DEBUG_CHANNEL(file);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
@@ -157,6 +161,7 @@
 }
 
 
+#ifndef UNIFIED_KERNEL
 /***********************************************************************
  *           open_builtin_exe_file
  *
@@ -184,6 +189,7 @@
     }
     return wine_dll_load_main_exe( exename, error, error_size, test_only, file_exists );
 }
+#endif
 
 
 /***********************************************************************
@@ -215,6 +221,7 @@
 }
 
 
+#ifndef UNIFIED_KERNEL
 /***********************************************************************
  *           find_exe_file
  *
@@ -260,6 +267,7 @@
 
     return FALSE;
 }
+#endif
 
 
 /***********************************************************************
@@ -581,8 +589,10 @@
     }
     argv[argc] = NULL;
 
+#ifndef UNIFIED_KERNEL
     __wine_main_argc = argc;
     __wine_main_argv = argv;
+#endif
     __wine_main_wargv = wargv;
 }
 
@@ -877,6 +887,63 @@
     return event;
 }
 
+#ifdef UNIFIED_KERNEL
+/*
+ * process_init() has been removed from wine-0.9.53, 
+ * but Linux Unified Kernel will use it in ntdll.dll, 
+ * so here it is.
+ */
+BOOL process_init(void)
+{
+    static const WCHAR kernel32W[] = {'k','e','r','n','e','l','3','2',0};
+    PEB *peb = NtCurrentTeb()->Peb;
+    RTL_USER_PROCESS_PARAMETERS *params = peb->ProcessParameters;
+    BOOL got_environment = TRUE;
+    HANDLE boot_event = 0;
+    int *psocketfd = (int *)(params + 1);
+
+    setbuf(stdout,NULL);
+    setbuf(stderr,NULL);
+
+    kernel32_handle = GetModuleHandleW(kernel32W);
+
+    LOCALE_Init();
+
+    if (!params->Environment)
+    {
+        /* Copy the parent environment */
+        if (!build_initial_environment( __wine_main_environ )) return FALSE;
+
+        /* convert old configuration to new format */
+        convert_old_config();
+
+        got_environment = set_registry_environment();
+        set_additional_environment();
+    }
+
+    init_windows_dirs();
+    init_current_directory( &params->CurrentDirectory );
+
+    /* start wineboot */
+    if (!(*psocketfd))
+        boot_event = start_wineboot();
+
+    if (boot_event)
+    {
+        if (WaitForSingleObject( boot_event, 30000 )) WARN( "boot event wait timed out\n" );
+        CloseHandle( boot_event );
+        /* if we didn't find environment section, try again now that wineboot has run */
+        if (!got_environment)
+        {
+            set_registry_environment();
+            set_additional_environment();
+        }
+    }
+    set_library_wargv(__wine_main_argv);
+
+    return TRUE;
+}
+#endif
 
 /***********************************************************************
  *           start_process
@@ -1168,6 +1235,7 @@
 }
 
 
+#ifndef UNIFIED_KERNEL
 /***********************************************************************
  *           alloc_env_string
  *
@@ -1291,6 +1359,7 @@
     close( fd[0] );
     return pid;
 }
+#endif
 
 
 /***********************************************************************
@@ -1592,6 +1661,7 @@
 }
 
 
+#ifndef UNIFIED_KERNEL
 /***********************************************************************
  *           create_cmd_process
  *
@@ -1711,6 +1781,7 @@
     HeapFree( GetProcessHeap(), 0, name );
     return ret;
 }
+#endif
 
 
 /**********************************************************************
@@ -1755,6 +1826,7 @@
 }
 
 
+#ifndef UNIFIED_KERNEL
 /**********************************************************************
  *       CreateProcessW          (KERNEL32.@)
  */
@@ -1894,6 +1966,7 @@
         TRACE( "started process pid %04x tid %04x\n", info->dwProcessId, info->dwThreadId );
     return retv;
 }
+#endif
 
 
 /**********************************************************************
@@ -1945,6 +2018,1111 @@
     CloseHandle( hFile );
 }
 
+#ifdef UNIFIED_KERNEL
+#define PEB_BASE 0x7ffdf000
+extern void set_child_socket_fd(int fd);
+void BaseProcessStart(unsigned long start_address, void *param);
+
+extern VOID RtlRosR32AttribsToNativeAttribs(OUT OBJECT_ATTRIBUTES * NativeAttribs,
+        IN SECURITY_ATTRIBUTES * Ros32Attribs OPTIONAL);
+
+extern NTSTATUS WINAPI UkQuerySection(
+        IN HANDLE SectionHandle,
+        IN SECTION_INFORMATION_CLASS SectionInformationClass,
+        OUT PVOID SectionInformation,
+        IN ULONG Length,
+        OUT PULONG ResultLength);
+
+extern NTSTATUS CDECL
+RtlRosCreateUserThread(IN HANDLE ProcessHandle,
+        IN POBJECT_ATTRIBUTES ObjectAttributes,
+        IN BOOLEAN CreateSuspended,
+        IN LONG StackZeroBits,
+        IN OUT PULONG StackReserve OPTIONAL,
+        IN OUT PULONG StackCommit OPTIONAL,
+        IN PVOID BaseStartAddress,
+        OUT PHANDLE ThreadHandle OPTIONAL,
+        OUT PCLIENT_ID ClientId OPTIONAL,
+        IN ULONG_PTR StartAddress,
+        IN ULONG_PTR Parameter);
+
+NTSTATUS WINAPI
+UkOpenFile( PHANDLE handle, ACCESS_MASK access,
+        POBJECT_ATTRIBUTES attr, PIO_STATUS_BLOCK io,
+        ULONG sharing, ULONG options );
+
+NTSTATUS WINAPI
+UkCreateSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+        const LARGE_INTEGER *size, ULONG protect,
+        ULONG sec_flags, HANDLE file );
+
+NTSTATUS WINAPI NtClose( HANDLE Handle );
+
+static const char fakedll_signature[] = "Wine placeholder DLL";
+
+static BOOL IsFakeDll(HANDLE h)
+{
+    IMAGE_DOS_HEADER *dos;
+    DWORD size;
+    BYTE buffer[sizeof(*dos) + sizeof(fakedll_signature)];
+
+    if (!ReadFile( h, buffer, sizeof(buffer), &size, NULL ) || size != sizeof(buffer))
+        return FALSE;
+    dos = (IMAGE_DOS_HEADER *)buffer;
+    if (dos->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;
+    if (dos->e_lfanew < size) return FALSE;
+    return !memcmp( dos + 1, fakedll_signature, sizeof(fakedll_signature) );
+}
+
+static BOOL IsValidPEApp(LPCWSTR AppName)
+{
+    HANDLE handle;
+
+    handle = CreateFileW(AppName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
+    if (handle == INVALID_HANDLE_VALUE)
+        return FALSE;
+    if (IsFakeDll(handle)) {
+        CloseHandle(handle);
+        return FALSE;
+    }
+    CloseHandle(handle);
+    return TRUE;
+}
+
+#ifdef UNIFIED_KERNEL_EXESO
+
+extern char *get_dlldir(char **default_path);
+static BOOL NativeToBuiltin(LPWSTR Native, LPWSTR Builtin, unsigned BuiltinLen)
+{
+    char *prefix = NULL;
+    char *c;
+    char name[MAX_PATH];
+    int  len;
+    WCHAR *p;
+    struct stat stat_buf;
+
+    p = strrchrW(Native, '\\');
+    if (p)
+        p++;
+    else
+        p = Native;
+
+    get_dlldir(&prefix);
+
+    len = strlen(prefix);
+    memcpy(name, prefix, len);
+    name[len++] = '/';
+    WideCharToMultiByte(CP_UNIXCP, 0, p, strlenW(p) + 1, name + len, sizeof(name) - len, 0, NULL);
+
+    c = name + len;
+    while (*c) {
+        *c = tolower(*c);
+        c++;
+    }
+
+    len = c - name;
+    if (strcasecmp(name + len - 4, ".exe")) {
+        memcpy(name + len, ".exe.so", sizeof(".exe.so"));
+        len += sizeof(".exe.so") - 1;
+    }
+    else {
+        memcpy(name + len, ".so", sizeof(".so"));
+        len += sizeof(".so") - 1;
+    }
+
+    if (!stat(name, &stat_buf)) {
+        MultiByteToWideChar(CP_UNIXCP, 0, name, len + 1, Builtin, BuiltinLen);
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static BOOL SearchApplication(LPWSTR AppName, LPWSTR NativeAppName,
+        unsigned NativeAppNameLen, LPWSTR BuiltinAppName,
+        unsigned BuiltinAppNameLen, PBOOL UseNative)
+{
+    WCHAR dotExe[] = {L'.',L'e',L'x',L'e', 0};
+    BOOL  Found = FALSE;
+
+    if (SearchPathW(NULL, AppName, dotExe, NativeAppNameLen, NativeAppName, NULL)) {
+        /* found pe format application */
+        if (!IsValidPEApp(NativeAppName)) {
+            if (NativeToBuiltin(NativeAppName, BuiltinAppName, BuiltinAppNameLen)) {
+                Found = TRUE;
+                *UseNative = FALSE;
+            }
+        } else {
+            Found = TRUE;
+            *UseNative = TRUE;
+        }
+    } else {
+        if (NativeToBuiltin(AppName, BuiltinAppName, BuiltinAppNameLen)) {
+            Found = TRUE;
+            *UseNative = FALSE;
+        }
+    }
+
+    return Found;
+}
+
+static inline void MakeBuiltinCmdLine(LPWSTR CmdLine, LPWSTR AppName, LPWSTR Params)
+{
+    WCHAR Quotation[] = {L'\"', 0};
+
+    CmdLine[0] = L'"';
+    strcpyW(CmdLine + 1, AppName);
+    strcatW(CmdLine, Quotation);
+    if (Params)
+        strcatW(CmdLine, Params);
+}
+
+#else
+
+static BOOL SearchApplication(LPWSTR AppName, LPWSTR NativeAppName,
+        unsigned NativeAppNameLen, LPWSTR BuiltinAppName,
+        unsigned BuiltinAppNameLen, PBOOL UseNative)
+{
+    WCHAR dotExe[] = {L'.',L'e',L'x',L'e', 0};
+
+    if (SearchPathW(NULL, AppName, dotExe, NativeAppNameLen, NativeAppName, NULL)
+            && IsValidPEApp(NativeAppName))
+        return TRUE;
+
+    return FALSE;
+}
+
+#endif
+
+/*
+ * GetFileName
+ *
+ * Helper for CreateProcessW: retrieve the file name to load from the
+ * app name and command line. Store the file name in buffer, and
+ * return a possibly modified command line.
+ *
+ * FIXME: use CurDir to search for the executable file in the new working directory
+ *
+ * modified from ReactOS
+ */
+static LPWSTR GetFileName(LPCWSTR CurDir, LPCWSTR AppName, LPWSTR CmdLine, LPWSTR Buffer,
+        unsigned BufLen, LPWSTR BuiltinCmdLine, LPWSTR BuiltinAppName, unsigned BuiltinAppNameLen)
+{
+    WCHAR *Name, *Pos, *Ret = NULL;
+    WCHAR Quotation[] = {L'\"', 0};
+    BOOL  UseNative = TRUE;
+    const WCHAR *p;
+
+    /* if we have an app name, everything is easy */
+    if (AppName) {
+        if (!SearchApplication((LPWSTR)AppName, Buffer, BufLen, BuiltinAppName, 
+                    BuiltinAppNameLen, &UseNative)) {
+            SetLastError(ERROR_FILE_NOT_FOUND);
+            return NULL;
+        }
+
+        /* use the unmodified app name as file name */
+        if (!UseNative)
+            lstrcpynW(Buffer, AppName, BufLen );
+        Ret = CmdLine;
+        if (!Ret || !CmdLine[0]) {
+            /* no command-line, create one */
+            Ret = RtlAllocateHeap(GetProcessHeap(), 0,
+                    (strlenW(Buffer) + 3) * sizeof(WCHAR));
+            if (Ret) {
+                Ret[0] = L'"';
+                strcpyW(Ret + 1, Buffer);
+                strcatW(Ret, Quotation);
+            }
+        }
+#ifdef UNIFIED_KERNEL_EXESO
+        if (!UseNative)
+            MakeBuiltinCmdLine(BuiltinCmdLine, BuiltinAppName, NULL);
+#endif
+        return Ret;
+    }
+
+    if (!CmdLine) {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return NULL;
+    }
+
+    /* first check for a quoted file name */
+    if (L'"' == CmdLine[0] && (p = strchrW(CmdLine + 1, L'"'))) {
+        int Len = p - CmdLine - 1;
+
+        /* extract the quoted portion as file name */
+        Name = RtlAllocateHeap(GetProcessHeap(), 0, (Len + 1) * sizeof(WCHAR));
+        if (!Name) {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return NULL;
+        }
+        memcpy(Name, CmdLine + 1, Len * sizeof(WCHAR));
+        Name[Len] = L'\0';
+
+        if (!SearchApplication(Name, Buffer, BufLen, BuiltinAppName, BuiltinAppNameLen, &UseNative)) {
+            RtlFreeHeap(GetProcessHeap(), 0, Name);
+            SetLastError(ERROR_FILE_NOT_FOUND);
+            return NULL;
+        }
+
+        if (!UseNative)
+            memcpy(Buffer, Name, Len * sizeof(WCHAR) + sizeof(WCHAR));
+        strcpyW(Name, ++p);	/* backup param */
+        Ret = CmdLine;
+        Ret[0] = L'"';
+        strcpyW(Ret + 1, Buffer);
+        strcatW(Ret, Quotation);
+        strcatW(Ret, Name);
+
+#ifdef UNIFIED_KERNEL_EXESO
+        if (!UseNative)
+            MakeBuiltinCmdLine(BuiltinCmdLine, BuiltinAppName, (LPWSTR)++p);
+#endif
+
+        RtlFreeHeap(GetProcessHeap(), 0, Name);
+        return Ret;
+    }
+
+    /* now try the command-line word by word */
+    Name = RtlAllocateHeap(GetProcessHeap(), 0, (strlenW(CmdLine) + 1) * sizeof(WCHAR));
+    if (!Name) {
+        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+        return NULL;
+    }
+    Pos = Name;
+    p = CmdLine;
+
+    while (*p) {
+        do
+            *Pos++ = *p++;
+        while (*p && L' ' != *p);
+        *Pos = 0;
+
+        if (!SearchApplication(Name, Buffer, BufLen, BuiltinAppName, BuiltinAppNameLen, &UseNative))
+            continue;
+
+        if (!UseNative)
+            strcpyW(Buffer, Name);
+        Ret = CmdLine;
+
+#ifdef UNIFIED_KERNEL_EXESO
+        if (!UseNative)
+            MakeBuiltinCmdLine(BuiltinCmdLine, BuiltinAppName, (LPWSTR)p);
+#endif
+        break;
+    }
+
+    if (!Ret) {
+        RtlFreeHeap(GetProcessHeap(), 0, Name); /* no change necessary */
+        return Ret;
+    }
+
+    /* now build a new command-line with quotes */
+    Ret = RtlAllocateHeap(GetProcessHeap(), 0, (strlenW(CmdLine) + 3 + strlenW(Buffer)) * sizeof(WCHAR));
+    if (!Ret) {
+        RtlFreeHeap(GetProcessHeap(), 0, Name); /* no change necessary */
+        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+        return NULL;
+    }
+    Ret[0] = L'"';
+    strcpyW(Ret + 1, Buffer);
+    strcatW(Ret, Quotation);
+    strcatW(Ret, p);
+
+    RtlFreeHeap(GetProcessHeap(), 0, Name);
+    return Ret;
+}
+
+/* modified from ReactOS */
+HANDLE KlMapFile(LPCWSTR lpApplicationName)
+{
+    HANDLE hFile;
+    IO_STATUS_BLOCK IoStatusBlock;
+    UNICODE_STRING ApplicationNameString;
+    OBJECT_ATTRIBUTES ObjectAttributes;
+    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
+    NTSTATUS Status;
+    HANDLE hSection;
+
+    hFile = NULL;
+
+    if (!RtlDosPathNameToNtPathName_U(lpApplicationName, &ApplicationNameString, NULL, NULL)) {
+        SetLastError(ERROR_PATH_NOT_FOUND);
+        return NULL;
+    }
+    InitializeObjectAttributes(&ObjectAttributes,
+            &ApplicationNameString,
+            OBJ_CASE_INSENSITIVE,
+            NULL,
+            SecurityDescriptor);
+
+    /* Try to open the executable */
+
+    Status = UkOpenFile(&hFile,
+            SYNCHRONIZE|FILE_EXECUTE|FILE_READ_DATA,
+            &ObjectAttributes,
+            &IoStatusBlock,
+            FILE_SHARE_DELETE|FILE_SHARE_READ,
+            FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE);
+
+    RtlFreeUnicodeString (&ApplicationNameString);
+
+    if (Status) {
+        SetLastError(Status);
+        return NULL;
+    }
+    Status = UkCreateSection(&hSection,
+            SECTION_ALL_ACCESS,
+            NULL,
+            NULL,
+            PAGE_EXECUTE,
+            SEC_IMAGE,
+            hFile);
+    NtClose(hFile);
+
+    if (Status) {
+        SetLastError(Status);
+        return NULL;
+    }
+
+    return hSection;
+}
+
+/* modified from ReactOS */
+HANDLE KlCreateFirstThread(HANDLE ProcessHandle,
+        LPSECURITY_ATTRIBUTES lpThreadAttributes,
+        PSECTION_IMAGE_INFORMATION Sii,
+        LPTHREAD_START_ROUTINE lpStartAddress,
+        DWORD dwCreationFlags,
+        LPDWORD lpThreadId)
+{
+    OBJECT_ATTRIBUTES oaThreadAttribs;
+    CLIENT_ID cidClientId;
+    PVOID pTrueStartAddress = NULL;
+    NTSTATUS nErrCode;
+    HANDLE hThread;
+
+    /* convert the thread attributes */
+    RtlRosR32AttribsToNativeAttribs(&oaThreadAttribs, lpThreadAttributes);
+
+    /* native image */
+    if(Sii->ImageSubsystem != IMAGE_SUBSYSTEM_NATIVE)
+        pTrueStartAddress = NULL;
+    /* Win32 image */
+    /* FIXME: nothing to do with win32 image */
+    else
+        ERR("Nothing to do with Win32 image!\n");
+
+    /* create the first thread */
+    nErrCode = RtlRosCreateUserThread(ProcessHandle,
+            &oaThreadAttribs,
+            dwCreationFlags & CREATE_SUSPENDED,
+            0,
+            &(Sii->StackReserved),
+            &(Sii->StackCommit),
+            pTrueStartAddress,
+            &hThread,
+            &cidClientId,
+            (ULONG_PTR)lpStartAddress,
+            (ULONG_PTR)PEB_BASE);
+    /* failure */
+    if(nErrCode) {
+        SetLastError(nErrCode);
+        return NULL;
+    }
+
+    /* success */
+    if(lpThreadId) 
+        *lpThreadId = (DWORD)cidClientId.UniqueThread;
+
+    return hThread;
+}
+
+static NTSTATUS KlInitPeb(HANDLE ProcessHandle,
+        PRTL_USER_PROCESS_PARAMETERS Ppb,
+        PVOID * ImageBaseAddress,
+        ULONG ImageSubSystem)
+{
+    PWCHAR ptr;
+    PVOID EnvPtr = NULL;
+    PVOID ParentEnv = NULL;
+    PVOID PpbBase = NULL;
+    ULONG offset = 0;
+    ULONG_PTR EnvSize = 0, PpbSize = 0;
+    ULONG_PTR EnvSize1 = 0;
+    ULONG_PTR ByteWritten = 0;
+    ULONG peb_base = 0x7FFDF000;
+    NTSTATUS Status;
+
+    if (Ppb->Environment) {
+        ptr = Ppb->Environment;
+        while (*ptr)
+            while (*ptr++);
+        ptr++;
+        EnvSize = ((ULONG)ptr - (ULONG)Ppb->Environment);
+        ParentEnv = Ppb->Environment;
+    }
+
+    if (EnvSize != 0) {
+        EnvSize1 = EnvSize;
+        Status = NtAllocateVirtualMemory(ProcessHandle,
+                &EnvPtr,
+                0,
+                &EnvSize1,
+                MEM_COMMIT,
+                PAGE_READWRITE);
+        if (Status) {
+            return(Status);
+        }
+
+        NtWriteVirtualMemory(ProcessHandle,
+                EnvPtr,
+                ParentEnv,
+                EnvSize,
+                &ByteWritten);
+    }
+
+    /* create ppb in child space*/
+    PpbSize = Ppb->AllocationSize;
+
+    Status = NtAllocateVirtualMemory(ProcessHandle,
+            &PpbBase,
+            0,
+            &PpbSize,
+            MEM_COMMIT,
+            PAGE_READWRITE);
+    if (Status)
+        return Status;
+
+    NtWriteVirtualMemory(ProcessHandle,
+            PpbBase,
+            Ppb,
+            PpbSize,
+            &ByteWritten);
+
+    /* write environment */
+    offset = FIELD_OFFSET(RTL_USER_PROCESS_PARAMETERS, Environment);
+    NtWriteVirtualMemory(ProcessHandle,
+            (PVOID)((ULONG)PpbBase + offset),
+            &EnvPtr,
+            sizeof(EnvPtr),
+            &ByteWritten);
+
+    /* write point to ppb */
+    offset = FIELD_OFFSET(PEB, ProcessParameters);
+    NtWriteVirtualMemory(ProcessHandle,
+            (PVOID)(peb_base + offset),
+            &PpbBase,
+            sizeof(PpbBase),
+            &ByteWritten);
+
+    /* FIXME: write image subsystem ? */
+    offset = FIELD_OFFSET(PEB, ImageSubSystem);
+    NtWriteVirtualMemory(ProcessHandle,
+            (PVOID)(peb_base + offset),
+            &ImageSubSystem,
+            sizeof(ImageSubSystem),
+            &ByteWritten);
+
+    /* read image base address */
+    offset = FIELD_OFFSET(PEB, ImageBaseAddress);
+    NtReadVirtualMemory(ProcessHandle,
+            (PVOID)(peb_base + offset),
+            ImageBaseAddress,
+            sizeof(PVOID),
+            &ByteWritten);
+
+    return STATUS_SUCCESS;
+}
+
+#ifdef UNIFIED_KERNEL_EXESO
+BOOL RunBuiltinApp(LPWSTR lpApplicationName,
+        LPWSTR lpCommandLine,
+        LPCWSTR NativeAppName,
+        LPWSTR NativeCmdLine,
+        LPSECURITY_ATTRIBUTES lpProcessAttributes,
+        LPSECURITY_ATTRIBUTES lpThreadAttributes,
+        BOOL bInheritHandles,
+        DWORD dwCreationFlags,
+        LPVOID lpEnvironment,
+        LPCWSTR lpCurrentDirectory,
+        LPSTARTUPINFOW lpStartupInfo,
+        LPPROCESS_INFORMATION lpProcessInformation)
+{
+    WCHAR *TidyCmdLine = lpCommandLine;
+    pid_t pid;
+    int socketfd[2];
+    int pipefd[2];
+    HANDLE process_info;
+    NTSTATUS Status;
+    BOOL success = FALSE;
+    CLIENT_ID cid;
+    OBJECT_ATTRIBUTES attr;
+    HANDLE wine_phandle, wine_thandle;
+
+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, socketfd) == -1) {
+        SetLastError( ERROR_TOO_MANY_OPEN_FILES );
+        return FALSE;
+    }
+    wine_server_send_fd(socketfd[1]);
+    close(socketfd[1]);
+
+    SERVER_START_REQ( new_process )
+    {
+        req->inherit_all    = bInheritHandles;
+        req->create_flags   = dwCreationFlags;
+        req->socket_fd      = socketfd[1];
+        req->exe_file       = NULL;
+        req->process_access = PROCESS_ALL_ACCESS;
+        req->process_attr   = (lpProcessAttributes
+                && (lpProcessAttributes->nLength >= sizeof(*lpProcessAttributes))
+                && lpProcessAttributes->bInheritHandle)
+            ? OBJ_INHERIT : 0;
+        req->thread_access  = THREAD_ALL_ACCESS;
+        req->thread_attr    = (lpThreadAttributes
+                && (lpThreadAttributes->nLength >= sizeof(*lpThreadAttributes))
+                && lpThreadAttributes->bInheritHandle)
+            ? OBJ_INHERIT : 0;
+
+        if (lpStartupInfo && lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) {
+            req->hstdin = lpStartupInfo->hStdInput;
+            req->hstdout = lpStartupInfo->hStdOutput;
+            req->hstderr = lpStartupInfo->hStdError;
+        } else {
+            req->hstdin = NtCurrentTeb()->Peb->ProcessParameters->hStdInput;
+            req->hstdout = NtCurrentTeb()->Peb->ProcessParameters->hStdOutput;
+            req->hstderr = NtCurrentTeb()->Peb->ProcessParameters->hStdError;
+        }
+
+        if (dwCreationFlags & CREATE_NEW_CONSOLE) {
+            /* TODO: handles for new console can't be controlled temporarily */
+            if (is_console_handle(req->hstdin))
+                req->hstdin = INVALID_HANDLE_VALUE;
+            if (is_console_handle(req->hstdout))
+                req->hstdout = INVALID_HANDLE_VALUE;
+            if (is_console_handle(req->hstderr))
+                req->hstderr = INVALID_HANDLE_VALUE;
+        }
+
+        Status = wine_server_call_err( req );
+
+        process_info = reply->info;
+        wine_phandle = reply->phandle;
+        wine_thandle = reply->thandle;
+    }
+    SERVER_END_REQ;
+
+    if (Status) {
+        close(socketfd[0]);
+        return FALSE;
+    }
+
+    if (pipe(pipefd) == -1) {
+        close(socketfd[0]);
+        return FALSE;
+    }
+
+    if (!(pid = fork())) {
+        char socket_env[64];
+        char pipe_env[64];
+        char app_env[MAX_PATH + 64];
+        char cmdline_env[MAX_PATH * 4 + 64];
+        char **argv = build_argv(TidyCmdLine, 1);
+
+        close(pipefd[0]);
+        sprintf(socket_env, "WINESERVERSOCKET=%u", socketfd[0]);
+        sprintf(pipe_env, "PIDTIDPIPE=%u", pipefd[1]);
+        strcpy(app_env, "NATIVEAPP=");
+        WideCharToMultiByte(CP_UNIXCP, 0, NativeAppName, strlenW(NativeAppName) + 1,
+                app_env + strlen(app_env), sizeof(app_env) - strlen(app_env), 0, NULL);
+        strcpy(cmdline_env, "NATIVECMDLINE=");
+        WideCharToMultiByte(CP_UNIXCP, 0, NativeCmdLine, strlenW(NativeCmdLine) + 1,
+                cmdline_env + strlen(cmdline_env), MAX_PATH * 4, 0, NULL);
+        putenv(socket_env);
+        putenv(pipe_env);
+        putenv(app_env);
+        putenv(cmdline_env);
+        if (argv)
+            wine_exec_wine_binary(0, argv, getenv("WINELOADER"));
+        _exit(1);
+    }
+
+    close(socketfd[0]);
+    close(pipefd[1]);
+    if (pid == -1) {
+        CloseHandle(process_info);
+        close(pipefd[0]);
+        return FALSE;
+    }
+
+    WaitForSingleObject(process_info, INFINITE);
+
+    SERVER_START_REQ(get_new_process_info)
+    {
+        req->info = process_info;
+        wine_server_call(req);
+        success = reply->success;
+    }
+    SERVER_END_REQ;
+
+    CloseHandle(process_info);
+    if (success) {
+        read(pipefd[0], &lpProcessInformation->dwProcessId, sizeof(lpProcessInformation->dwProcessId));
+        read(pipefd[0], &lpProcessInformation->dwThreadId, sizeof(lpProcessInformation->dwThreadId));
+    }else {
+        close(pipefd[0]);
+        return FALSE;
+    }
+
+    close(pipefd[0]);
+
+    cid.UniqueProcess = (HANDLE)lpProcessInformation->dwProcessId;
+    cid.UniqueThread = (HANDLE)lpProcessInformation->dwThreadId;
+    memset(&attr, 0, sizeof(attr));
+    attr.Length = sizeof(attr);
+    Status = NtOpenProcess(&lpProcessInformation->hProcess, PROCESS_ALL_ACCESS, &attr, &cid);
+    if(Status)
+        return FALSE;
+    Status = NtOpenThread(&lpProcessInformation->hThread, THREAD_ALL_ACCESS, &attr, &cid);
+    if(Status) {
+        NtClose(lpProcessInformation->hProcess);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+#endif
+
+    void
+GetFullCmdLine(LPWSTR lpCommandLine)
+{
+    WCHAR *cmdline = lpCommandLine;
+    /* FIXME */
+    WCHAR short_cmd[1024], long_cmd[1024], remain[1024];
+    WCHAR *temp;
+    int i;
+
+    if (*lpCommandLine == L'"') {
+        strcpyW(short_cmd, lpCommandLine + 1);
+        temp = strchrW(short_cmd, L'"');
+        if (temp) {
+            strcpyW(remain, temp);
+            *temp = L'\0';
+        }
+
+        /* FIXME */
+        if (!GetLongPathNameW(short_cmd, long_cmd, 1024)) {
+            lstrcpynW(long_cmd, short_cmd, 1024);
+        }
+        *cmdline++ = L'"';
+    } else {
+        strcpyW(short_cmd, lpCommandLine);
+        temp = strchrW(short_cmd, L' ');
+        if (temp) {
+            strcpyW(remain, temp);
+            *temp = L'\0';
+        }
+        else{
+            return;
+        }
+
+        /* FIXME */
+        if (!GetLongPathNameW(short_cmd, long_cmd, 1024)) {
+            lstrcpynW(long_cmd, short_cmd, 1024);
+        }
+    }
+
+    for (i = 0; ;i++) {
+        *cmdline++ = long_cmd[i];
+        if (long_cmd[i + 1] == L'\0')
+            break;
+    }
+    *cmdline = L'\0';
+
+    strcatW(lpCommandLine, remain);
+}
+
+    BOOL WINAPI
+CreateProcessW(LPCWSTR lpApplicationName,
+        LPWSTR lpCommandLine,
+        LPSECURITY_ATTRIBUTES lpProcessAttributes,
+        LPSECURITY_ATTRIBUTES lpThreadAttributes,
+        BOOL bInheritHandles,
+        DWORD dwCreationFlags,
+        LPVOID lpEnvironment,
+        LPCWSTR lpCurrentDirectory,
+        LPSTARTUPINFOW lpStartupInfo,
+        LPPROCESS_INFORMATION lpProcessInformation)
+{
+    HANDLE hSection, hProcess, hThread;
+    HANDLE hStdIn, hStdOut, hStdErr;
+    HANDLE process_info;
+    HANDLE wine_phandle, wine_thandle;
+    ULONG ProcAttributes = 0;
+    PVOID ProcSecurity = NULL;
+    PVOID ImageBaseAddress;
+    int socketfd[2];
+
+    WCHAR* TidyCmdLine;
+    WCHAR Name[MAX_PATH];
+    WCHAR* TempCurrentDirectory;
+    WCHAR TempApplicationName[256];
+    WCHAR* tmp;
+    WCHAR dotExe[] = {'.','e','x','e', 0};
+    WCHAR BuiltinCmdLine[MAX_PATH * 4] = {0}, BuiltinAppName[MAX_PATH] = {0};
+    WCHAR FullCmdLine[256] = {L'\0'};
+
+    UNICODE_STRING ImagePathName_U;
+    UNICODE_STRING CmdLine_U;
+    UNICODE_STRING CurrentDirectory_U;
+    UNICODE_STRING RuntimeInfo_U;
+    SECTION_IMAGE_INFORMATION Sii;
+    OBJECT_ATTRIBUTES ProcObjectAttributes;
+    PROCESS_PRIORITY_CLASS PriorityClass;
+    PRTL_USER_PROCESS_PARAMETERS ppb;
+    PROCESS_BASIC_INFORMATION ProcessBasicInfo;
+
+    NTSTATUS Status;
+
+    TRACE("CreateProcessW(1:%s,2:%s,3:%p,4:%p,5:%d,6:%d,7:%p,8:%p,9:%p,10:%p)\n",
+            debugstr_w(lpApplicationName),
+            debugstr_w(lpCommandLine),
+            lpProcessAttributes,
+            lpThreadAttributes,
+            bInheritHandles,
+            dwCreationFlags,
+            lpEnvironment,
+            lpCurrentDirectory,
+            lpStartupInfo,
+            lpProcessInformation);
+
+    /* get long path name of commandline */
+    if (lpCommandLine) {
+        strcpyW(FullCmdLine, lpCommandLine);
+        GetFullCmdLine(FullCmdLine);
+    }
+
+    /* get file name */
+    TidyCmdLine = GetFileName(lpCurrentDirectory, lpApplicationName,
+            FullCmdLine, Name, sizeof(Name)/sizeof(WCHAR),
+            BuiltinCmdLine, BuiltinAppName, sizeof(BuiltinAppName) / sizeof(WCHAR));
+    if (!TidyCmdLine)
+        return FALSE;
+#ifdef UNIFIED_KERNEL_EXESO
+    if (*BuiltinAppName && *BuiltinCmdLine) {
+        return RunBuiltinApp(BuiltinAppName,
+                BuiltinCmdLine,
+                Name,
+                FullCmdLine,
+                lpProcessAttributes,
+                lpThreadAttributes,
+                bInheritHandles,
+                dwCreationFlags,
+                lpEnvironment,
+                lpCurrentDirectory,
+                lpStartupInfo,
+                lpProcessInformation);
+    }
+#endif
+
+    /* deal with file name */
+    if (lpApplicationName && lpApplicationName[0])
+        strcpyW(TempApplicationName, lpApplicationName);
+    else {
+        if (L'"' == TidyCmdLine[0]) {
+            /* command line: "*.exe" */
+            strcpyW(TempApplicationName, TidyCmdLine + 1);
+            tmp = strchrW(TempApplicationName, L'"');
+            if (tmp)
+                *tmp = L'\0';
+        } else {
+            /* command line: *.exe */
+            strcpyW(TempApplicationName, TidyCmdLine);
+            tmp = strchrW(TempApplicationName, L' ');
+            /* the command line with '"' and followed by ' ' is invalid*/
+            if (tmp) *tmp = L'\0';
+            else if ((tmp = strchrW(TempApplicationName, L'"'))) *tmp = L'\0';
+        }
+    }
+    tmp = max(strchrW(TempApplicationName, L'\\'), strchrW(TempApplicationName, L'/'));
+    if (!tmp)
+        tmp = TempApplicationName;
+    if (!strchrW(TempApplicationName, L'.'))
+        strcatW(TempApplicationName, dotExe);
+
+    /*TODO: search path*/
+
+    RtlInitUnicodeString(&ImagePathName_U, TempApplicationName);
+    RtlInitUnicodeString(&CmdLine_U, TidyCmdLine);
+
+    if (lpCurrentDirectory != NULL)
+        RtlInitUnicodeString(&CurrentDirectory_U,lpCurrentDirectory);
+    else {
+        if(!(TempCurrentDirectory = RtlAllocateHeap(GetProcessHeap(), 0, 256))) {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return FALSE;
+        }
+        GetCurrentDirectoryW(256, TempCurrentDirectory);
+        RtlInitUnicodeString(&CurrentDirectory_U, TempCurrentDirectory);
+        RtlFreeHeap(GetProcessHeap(), 0, TempCurrentDirectory);
+    }
+
+    /* FIXME: .cmd and .bat will not be processed */
+
+    /* map executable file */
+    hSection = KlMapFile(TempApplicationName);
+    if (!hSection)
+        return FALSE;
+
+    /* TODO: 16bit applications 
+     * if (!hSection)
+     * ...
+     */
+    /* query section infomation */
+    Status = UkQuerySection(hSection, SectionImageInformation, &Sii, sizeof(Sii), NULL);
+    if (Status) {
+        NtClose(hSection);
+        WARN("NtQuerySection() failed(Status %x)\n", Status);
+        SetLastError(RtlNtStatusToDosError(Status));
+        return FALSE;
+    }
+
+    if (0 != (Sii.ImageCharacteristics & IMAGE_FILE_DLL)) {
+        NtClose(hSection);
+        WARN("Can't execute a DLL\n");
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    if (IMAGE_SUBSYSTEM_WINDOWS_GUI != Sii.ImageSubsystem 
+            && IMAGE_SUBSYSTEM_WINDOWS_CUI != Sii.ImageSubsystem) {
+        NtClose(hSection);
+        WARN("Invalid subsystem %d\n", Sii.ImageSubsystem);
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    /* initialize object */
+    if(lpProcessAttributes) {
+        if(lpProcessAttributes->bInheritHandle)
+            ProcAttributes |= OBJ_INHERIT;
+        ProcSecurity = lpProcessAttributes->lpSecurityDescriptor;
+    }
+    InitializeObjectAttributes(&ProcObjectAttributes, NULL, ProcAttributes, NULL, ProcSecurity);
+
+    /* initialize priority */
+    PriorityClass.Foreground = FALSE;
+
+    if(dwCreationFlags & IDLE_PRIORITY_CLASS)
+        PriorityClass.PriorityClass = PROCESS_PRIOCLASS_IDLE;
+    else if(dwCreationFlags & BELOW_NORMAL_PRIORITY_CLASS)
+        PriorityClass.PriorityClass = PROCESS_PRIOCLASS_BELOW_NORMAL;
+    else if(dwCreationFlags & NORMAL_PRIORITY_CLASS)
+        PriorityClass.PriorityClass = PROCESS_PRIOCLASS_NORMAL;
+    else if(dwCreationFlags & ABOVE_NORMAL_PRIORITY_CLASS)
+        PriorityClass.PriorityClass = PROCESS_PRIOCLASS_ABOVE_NORMAL;
+    else if(dwCreationFlags & HIGH_PRIORITY_CLASS)
+        PriorityClass.PriorityClass = PROCESS_PRIOCLASS_HIGH;
+    else if(dwCreationFlags & REALTIME_PRIORITY_CLASS)
+        /* FIXME - This is a privileged operation. If we don't have the privilege we should
+           rather use PROCESS_PRIOCLASS_HIGH. */
+        PriorityClass.PriorityClass = PROCESS_PRIOCLASS_REALTIME;
+    else
+        /* FIXME - what to do in this case? */
+        PriorityClass.PriorityClass = PROCESS_PRIOCLASS_NORMAL;
+
+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, socketfd) == -1) {
+        SetLastError(ERROR_TOO_MANY_OPEN_FILES);
+        return FALSE;
+    }
+    wine_server_send_fd(socketfd[1]);
+    close(socketfd[1]);
+    /* NtCreateProcess*/
+    NtCreateProcess(&hProcess,
+            PROCESS_ALL_ACCESS,
+            &ProcObjectAttributes,
+            NtCurrentProcess(),
+            bInheritHandles,
+            hSection,
+            NULL,
+            NULL);
+
+    NtSetInformationProcess(hProcess,
+            ProcessPriorityClass,
+            &PriorityClass,
+            sizeof(PROCESS_PRIORITY_CLASS));
+
+    /* TODO: send set information message */
+
+    /* creat ppb */
+    RtlInitUnicodeString(&RuntimeInfo_U, NULL);
+    if (lpStartupInfo) {
+        if (lpStartupInfo->lpReserved2) {
+            /* FIXME:
+             *    ROUND_UP(xxx,2) + 2 is a dirty hack. RtlCreateProcessParameters 
+             *    assumes that the runtimeinfo is a unicode string and 
+             *    use RtlCopyUnicodeString for duplication.
+             *    If is possible that this function overwrite the last information 
+             *    in runtimeinfo with the null terminator for the unicode string.
+             */
+            RuntimeInfo_U.Length = (lpStartupInfo->cbReserved2 + 1) & ~1; 
+            RuntimeInfo_U.MaximumLength = (lpStartupInfo->cbReserved2 + 1) & ~1;
+            RuntimeInfo_U.Buffer = RtlAllocateHeap(GetProcessHeap(), 0, 
+                    RuntimeInfo_U.Length);
+            memcpy(RuntimeInfo_U.Buffer, lpStartupInfo->lpReserved2, 
+                    lpStartupInfo->cbReserved2);
+        }
+    }
+
+    set_child_socket_fd(socketfd[0]);
+
+    if (!(ppb = create_user_params( TempApplicationName, TidyCmdLine, lpCurrentDirectory,
+                    lpEnvironment, dwCreationFlags, lpStartupInfo))) 
+        return FALSE;
+
+    set_child_socket_fd(0);
+
+    if (lpStartupInfo && lpStartupInfo->lpReserved2)
+        RtlFreeHeap(GetProcessHeap(), 0, RuntimeInfo_U.Buffer);
+
+    /* copy ppb->CurrentDirectoryHandle */
+    if (ppb->CurrentDirectory.Handle)
+    {
+        NtDuplicateObject(NtCurrentProcess(),
+                ppb->CurrentDirectory.Handle,
+                hProcess,
+                &ppb->CurrentDirectory.Handle,
+                0,
+                TRUE,
+                DUPLICATE_SAME_ACCESS);
+    }
+
+    /* close section */
+    NtClose(hSection);
+
+    /* initialize data to send to wine server */ 
+    NtQueryInformationProcess(hProcess,
+            ProcessBasicInformation,
+            &ProcessBasicInfo,
+            sizeof(ProcessBasicInfo),
+            NULL);
+
+    lpProcessInformation->dwProcessId = (DWORD) ProcessBasicInfo.UniqueProcessId;
+
+    if (Sii.ImageSubsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) {
+        /* do not create a console for GUI applications */
+        dwCreationFlags &= ~CREATE_NEW_CONSOLE;
+        dwCreationFlags |= DETACHED_PROCESS;
+    } else if (Sii.ImageSubsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI) {
+        if (!ppb->ConsoleHandle) /* FIXME: see dwCreationFlags */
+            dwCreationFlags |= CREATE_NEW_CONSOLE;
+    }
+
+    /* wine server */
+    SERVER_START_REQ( new_process )
+    {
+        req->inherit_all    = bInheritHandles;
+        req->create_flags   = dwCreationFlags;
+        req->socket_fd      = socketfd[1];
+        req->exe_file       = NULL;
+        req->process_access = PROCESS_ALL_ACCESS;
+        if (lpStartupInfo && lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) {
+            req->hstdin = lpStartupInfo->hStdInput;
+            req->hstdout = lpStartupInfo->hStdOutput;
+            req->hstderr = lpStartupInfo->hStdError;
+        } else {
+            req->hstdin = NtCurrentTeb()->Peb->ProcessParameters->hStdInput;
+            req->hstdout = NtCurrentTeb()->Peb->ProcessParameters->hStdOutput;
+            req->hstderr = NtCurrentTeb()->Peb->ProcessParameters->hStdError;
+        }
+
+        if (dwCreationFlags & CREATE_NEW_CONSOLE) {
+            /* TODO: handles for new console can't be controlled temporarily */
+            if (is_console_handle(req->hstdin))
+                req->hstdin = INVALID_HANDLE_VALUE;
+            if (is_console_handle(req->hstdout))
+                req->hstdout = INVALID_HANDLE_VALUE;
+            if (is_console_handle(req->hstderr))
+                req->hstderr = INVALID_HANDLE_VALUE;
+        }
+
+        hStdIn = req->hstdin;
+        hStdOut = req->hstdout;
+        hStdErr = req->hstderr;
+
+        Status = wine_server_call_err( req );
+
+        process_info = reply->info;
+        wine_phandle = reply->phandle;
+        wine_thandle = reply->thandle;
+    }
+    SERVER_END_REQ;
+
+    if(Status) {
+        close(socketfd[0]);
+        SetLastError(RtlNtStatusToDosError(Status));
+        return FALSE;
+    }
+
+    /* set handle, FIXME: no duplication is done */
+    ppb->hStdInput = hStdIn;
+    ppb->hStdOutput = hStdOut;
+    ppb->hStdError = hStdErr;
+
+    CloseHandle(process_info);
+
+    /* copy ppb */
+    if (lpStartupInfo) {
+        ppb->dwFlags = lpStartupInfo->dwFlags;
+        if (ppb->dwFlags & STARTF_USESHOWWINDOW)
+            ppb->wShowWindow = lpStartupInfo->wShowWindow;
+        else
+            ppb->wShowWindow = SW_SHOWDEFAULT;
+        ppb->dwX = lpStartupInfo->dwX;
+        ppb->dwY = lpStartupInfo->dwY;
+        ppb->dwXSize = lpStartupInfo->dwXSize;
+        ppb->dwYSize = lpStartupInfo->dwYSize;
+        ppb->dwFillAttribute = lpStartupInfo->dwFillAttribute;
+    } else
+        ppb->Flags = 0;
+
+    KlInitPeb(hProcess, ppb, &ImageBaseAddress, Sii.ImageSubsystem);
+
+    RtlDestroyProcessParameters(ppb);
+
+    /* create first thread */
+    hThread = KlCreateFirstThread(hProcess,
+            lpThreadAttributes,
+            &Sii,
+            (PVOID)((ULONG_PTR)ImageBaseAddress + (ULONG)Sii.EntryPoint),
+            dwCreationFlags,
+            &lpProcessInformation->dwThreadId);
+    if (!hThread)
+        return FALSE;
+
+    /* store handle pair */
+    if (!store_handle_pair(hProcess, wine_phandle)) {
+        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+        return FALSE;
+    }
+    if (!store_handle_pair(hThread, wine_thandle)) {
+        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+        return FALSE;
+    }
+
+    /* FIXME:
+     * We use handles returned from system calls to do some stuff in CreateProcessW.  
+     * But the process and thread handles are illegal in wine server, and they 
+     * can't be used in other functions outside.
+     */
+
+    /* set process and thread handles*/
+    lpProcessInformation->hProcess = hProcess;
+    lpProcessInformation->hThread = hThread;
+
+    return TRUE;
+}
+#endif
 
 /***********************************************************************
  *           wait_input_idle
@@ -3044,3 +4222,24 @@
 
     return S_OK;
 }
+
+#ifdef UNIFIED_KERNEL
+void BaseProcessStart(unsigned long start_address, void *param)
+{
+    unsigned long   exit_code;
+    LPTHREAD_START_ROUTINE  entry;
+
+    __TRY
+    {
+        entry = (LPTHREAD_START_ROUTINE)start_address;
+        exit_code = entry(param);
+    }
+    __EXCEPT(UnhandledExceptionFilter)
+    {
+        exit_code = GetExceptionCode();
+    }
+    __ENDTRY;
+
+    ExitProcess(exit_code);
+}
+#endif
diff -urN wine-1.0/dlls/kernel32/sync.c wine-1.0-uk/dlls/kernel32/sync.c
--- wine-1.0/dlls/kernel32/sync.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/kernel32/sync.c	2009-08-19 10:13:55.000000000 +0800
@@ -47,6 +47,9 @@
 #include "kernel_private.h"
 
 #include "wine/debug.h"
+#ifdef UNIFIED_KERNEL
+#include "handle.h"
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(sync);
 
@@ -149,6 +152,108 @@
     return WaitForMultipleObjectsEx( count, handles, wait_all, timeout, FALSE );
 }
 
+#ifdef UNIFIED_KERNEL
+struct mix_handle
+{
+    HANDLE mixed[MAXIMUM_WAIT_OBJECTS];
+    int pos[MAXIMUM_WAIT_OBJECTS];
+    int count;
+    BOOLEAN wait_all;
+    BOOLEAN alertable;
+    LARGE_INTEGER * timeout;
+    int ret;
+    HANDLE notify_event;
+};
+
+static DWORD CALLBACK uk_wait(LPVOID uk);
+
+NTSTATUS mix_wait( DWORD count, const HANDLE *handles,
+        BOOLEAN wait_all, BOOLEAN alertable,
+        const LARGE_INTEGER *timeout )
+{
+    HANDLE * base = (HANDLE *)handles;
+    int i;
+    HANDLE interface = NULL;
+    NTSTATUS status = STATUS_UNSUCCESSFUL;
+    struct mix_handle h_wine, h_uk;
+
+    memset(&h_wine, 0, sizeof(struct mix_handle));
+    h_wine.wait_all = wait_all;
+    h_wine.alertable = alertable;
+    h_wine.timeout = (LARGE_INTEGER *)timeout;
+
+    h_wine.notify_event = CreateEventA(NULL, 1, 0, NULL);
+    if (!h_wine.notify_event)
+        return status;
+
+    memcpy(&h_uk, &h_wine, sizeof(struct mix_handle));
+
+    h_wine.mixed[h_wine.count++] = h_wine.notify_event;
+
+    for (i = 0; i < count; i++, base++) {
+        if(IS_UK_HANDLE(*base)) {
+            h_uk.mixed[h_uk.count] = *base;
+            h_uk.pos[h_uk.count++] = i;
+        } else {
+            h_wine.mixed[h_wine.count] = *base;
+            h_wine.pos[h_wine.count++] = i;
+        }
+    }
+
+    interface = CreateThread(NULL, 0, uk_wait, (LPVOID)&h_uk, 0, NULL);
+    if (!interface) {
+        NtClose(h_wine.notify_event);
+        return status;
+    }
+
+    h_wine.ret = NtWaitForMultipleObjects(h_wine.count, h_wine.mixed, wait_all, alertable, timeout);
+
+    if (HIWORD(h_uk.ret))  /* is it an error code? */
+        status = h_uk.ret;
+    else if (HIWORD(h_wine.ret))
+        status = h_wine.ret;
+    else if (h_wine.ret == STATUS_TIMEOUT || h_uk.ret == STATUS_TIMEOUT)
+        status = STATUS_TIMEOUT;
+    else if (wait_all && (h_wine.ret == STATUS_WAIT_0 )) /* h_wine.ret shouldn't be other value */ 
+        status = h_uk.ret;
+    else if (h_wine.ret <= STATUS_WAIT_63) {
+        if (h_uk.ret >= STATUS_WAIT_0 && h_uk.ret < STATUS_WAIT_0 + h_uk.count)
+            status = STATUS_WAIT_0 + 
+                         min(h_uk.pos[h_uk.ret - STATUS_WAIT_0], 
+                             h_wine.pos[h_wine.ret - STATUS_WAIT_0]);
+        else if(h_uk.ret >= STATUS_ABANDONED_WAIT_0 && 
+                h_uk.ret < STATUS_ABANDONED_WAIT_0 + h_uk.count) 
+            status = STATUS_ABANDONED_WAIT_0 +
+                         min(h_uk.pos[h_uk.ret - STATUS_ABANDONED_WAIT_0], 
+                             h_wine.pos[h_wine.ret - STATUS_WAIT_0]);
+    } else
+        status = h_wine.ret;
+    
+
+    TerminateThread(interface, 0);
+    WaitForSingleObject(interface, INFINITE);
+    NtClose(interface);
+
+    NtClose(h_wine.notify_event);
+
+    return status;
+}
+
+static DWORD CALLBACK uk_wait(LPVOID uk)
+{
+    struct mix_handle * h_uk = (struct mix_handle *)uk;
+
+    h_uk->ret = NtWaitForMultipleObjects(h_uk->count,
+            h_uk->mixed,
+            h_uk->wait_all,
+            h_uk->alertable,
+            h_uk->timeout);
+
+    SetEvent(h_uk->notify_event);
+    SuspendThread(GetCurrentThread());
+    return 0;
+}
+#endif
 
 /***********************************************************************
  *           WaitForMultipleObjectsEx   (KERNEL32.@)
@@ -161,6 +266,11 @@
     HANDLE hloc[MAXIMUM_WAIT_OBJECTS];
     LARGE_INTEGER time;
     unsigned int i;
+#ifdef UNIFIED_KERNEL
+    HANDLE * handle_table = hloc;
+    int count_wine = 0, count_u = 0;
+    BOOLEAN mix;
+#endif
 
     if (count > MAXIMUM_WAIT_OBJECTS)
     {
@@ -189,8 +299,25 @@
         }
     }
 
+#ifdef UNIFIED_KERNEL
+    for (; handle_table < hloc + count; handle_table++)
+        if (IS_UK_HANDLE(*handle_table))
+            count_u++;
+        else
+            count_wine++;
+
+    mix = (count_u && count_wine) ? 1 : 0;
+#endif
+
+#ifndef UNIFIED_KERNEL
     status = NtWaitForMultipleObjects( count, hloc, wait_all, alertable,
                                        get_nt_timeout( &time, timeout ) );
+#else
+    if (mix)
+        status = mix_wait( count, hloc, wait_all, alertable, get_nt_timeout(&time, timeout) );
+    else
+        status = NtWaitForMultipleObjects( count, hloc, wait_all, alertable, get_nt_timeout(&time, timeout));
+#endif
 
     if (HIWORD(status))  /* is it an error code? */
     {
diff -urN wine-1.0/dlls/kernel32/thread.c wine-1.0-uk/dlls/kernel32/thread.c
--- wine-1.0/dlls/kernel32/thread.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/kernel32/thread.c	2009-08-19 10:13:55.000000000 +0800
@@ -41,9 +41,15 @@
 #include "wine/debug.h"
 
 #include "kernel_private.h"
+#ifdef UNIFIED_KERNEL
+#include "handle.h"
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(thread);
 
+#ifdef UNIFIED_KERNEL
+extern int server_abort_thread( int status );
+#endif
 
 /***********************************************************************
  *           CreateThread   (KERNEL32.@)
@@ -57,6 +63,7 @@
 }
 
 
+#ifndef UNIFIED_KERNEL
 /***************************************************************************
  *                  CreateRemoteThread   (KERNEL32.@)
  *
@@ -112,6 +119,148 @@
     }
     return handle;
 }
+#else
+#define PAGE_SIZE       0x1000
+#define ROUNDUP(a, b) ((((a) + (b) - 1)/(b))*(b))
+
+struct debug_info
+{
+    char *str_pos;       /* current position in strings buffer */
+    char *out_pos;       /* current position in output buffer */
+    char  strings[1024]; /* buffer for temporary strings */
+    char  output[1024];  /* current output line */
+};
+
+struct ntdll_thread_data
+{
+    DWORD              fs;            /* 1d4 TEB selector */
+    DWORD              gs;            /* 1d8 libc selector; update winebuild if you move this! */
+    struct debug_info *debug_info;    /* 1dc info for debugstr functions */
+    int                request_fd;    /* 1e0 fd for sending server requests */
+    int                reply_fd;      /* 1e4 fd for receiving server replies */
+    int                wait_fd[2];    /* 1e8 fd for sleeping server requests */
+    void              *vm86_ptr;      /* 1f0 data for vm86 mode */
+    void              *pad[2];        /* 1f4 change this if you add fields! */
+};
+
+void ThreadStartup(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter)
+{
+    volatile UINT uExitCode = 0;
+    struct debug_info debug_info;
+    struct ntdll_thread_data *thread_data;
+
+    /* signal */
+    thread_data = (struct ntdll_thread_data *)NtCurrentTeb()->SystemReserved2;
+    thread_data->debug_info = &debug_info;
+    debug_info.str_pos = debug_info.strings;
+    debug_info.out_pos = debug_info.output;
+
+    __TRY
+    {
+        uExitCode = (lpStartAddress)((PVOID)lpParameter);
+    }
+    __EXCEPT(UnhandledExceptionFilter)
+    {
+        uExitCode = GetExceptionCode();
+    }
+    __ENDTRY;
+
+    ExitThread(uExitCode);
+}
+
+extern NTSTATUS
+RtlRosCreateUserThread(IN HANDLE ProcessHandle,
+        IN POBJECT_ATTRIBUTES ObjectAttributes,
+        IN BOOLEAN CreateSuspended,
+        IN LONG StackZeroBits,
+        IN OUT PULONG StackReserve OPTIONAL,
+        IN OUT PULONG StackCommit OPTIONAL,
+        IN PVOID BaseStartAddress,
+        OUT PHANDLE ThreadHandle OPTIONAL,
+        OUT PCLIENT_ID ClientId OPTIONAL,
+        IN ULONG_PTR StartAddress,
+        IN ULONG_PTR Parameter);
+
+    HANDLE WINAPI
+CreateRemoteThread(HANDLE hProcess,
+        LPSECURITY_ATTRIBUTES lpThreadAttributes,
+        SIZE_T dwStackSize,
+        LPTHREAD_START_ROUTINE lpStartAddress,
+        LPVOID lpParameter,
+        DWORD dwCreationFlags,
+        LPDWORD lpThreadId)
+{
+    HANDLE hThread;
+    CLIENT_ID cidClientId;
+    NTSTATUS nErrCode;
+    ULONG nStackReserve;
+    ULONG nStackCommit;
+    OBJECT_ATTRIBUTES oaThreadAttribs;
+    PIMAGE_NT_HEADERS pinhHeader = RtlImageNtHeader(NtCurrentTeb()->Peb->ImageBaseAddress);
+
+    /* FIXME: do more checks - e.g. the image may not have an optional header */
+    if(pinhHeader == NULL) {
+        nStackReserve = 0x100000;/* FIXME */
+        nStackCommit = PAGE_SIZE;
+    } else {
+        nStackReserve = pinhHeader->OptionalHeader.SizeOfStackReserve;
+        nStackCommit = pinhHeader->OptionalHeader.SizeOfStackCommit;
+    }
+
+    /* use defaults */
+    if(dwStackSize == 0);
+    /* dwStackSize specifies the size to reserve */
+    else if(dwCreationFlags & STACK_SIZE_PARAM_IS_A_RESERVATION)
+        nStackReserve = dwStackSize;
+    /* dwStackSize specifies the size to commit */
+    else
+        nStackCommit = dwStackSize;
+
+    /* fix the stack reserve size */
+    if(nStackCommit > nStackReserve)
+        nStackReserve = ROUNDUP(nStackCommit, 0x100000);
+
+    /* initialize the attributes for the thread object */
+    InitializeObjectAttributes(&oaThreadAttribs,
+            NULL,
+            0,
+            NULL,
+            NULL);
+
+    if(lpThreadAttributes) {
+        /* make the handle inheritable */
+        if(lpThreadAttributes->bInheritHandle)
+            oaThreadAttribs.Attributes |= OBJ_INHERIT;
+
+        /* user-defined security descriptor */
+        oaThreadAttribs.SecurityDescriptor = lpThreadAttributes->lpSecurityDescriptor;
+    }
+
+    /* create the thread */
+    nErrCode = RtlRosCreateUserThread(hProcess,
+            &oaThreadAttribs,
+            dwCreationFlags & CREATE_SUSPENDED,
+            0,
+            &nStackReserve,
+            &nStackCommit,
+            (LPTHREAD_START_ROUTINE)ThreadStartup,
+            &hThread,
+            &cidClientId,
+            (ULONG_PTR)lpStartAddress,
+            (ULONG_PTR)lpParameter);
+    /* failure */
+    if(nErrCode) {
+        SetLastError(nErrCode);
+        return NULL;
+    }
+
+    /* success */
+    if(lpThreadId)
+        *lpThreadId = (DWORD)cidClientId.UniqueThread;
+
+    return hThread;
+}
+#endif
 
 
 /***********************************************************************
@@ -165,7 +314,11 @@
     if (last)
     {
         LdrShutdownProcess();
+#ifndef UNIFIED_KERNEL
         exit( code );
+#else
+        NtTerminateProcess(GetCurrentProcess(), code);
+#endif
     }
     else
     {
@@ -185,9 +338,43 @@
 BOOL WINAPI TerminateThread( HANDLE handle,    /* [in] Handle to thread */
                              DWORD exit_code)  /* [in] Exit code for thread */
 {
+#ifndef UNIFIED_KERNEL
     NTSTATUS status = NtTerminateThread( handle, exit_code );
     if (status) SetLastError( RtlNtStatusToDosError(status) );
     return !status;
+#else
+    NTSTATUS status; 
+    BOOL self, last;
+    HANDLE wine_handle;
+
+    if (GetCurrentThread() != handle) {
+        struct handle_pair * pair = search_handle_pair(handle);
+        wine_handle = pair->wine_handle;
+    } else 
+        wine_handle = handle;
+
+    SERVER_START_REQ( terminate_thread )
+    {
+        req->handle    = wine_handle;
+        req->exit_code = exit_code;
+        status = wine_server_call( req );
+        self = !status && reply->self;
+        last = reply->last;
+    }
+    SERVER_END_REQ;
+
+    if (self) {
+        if (last) {
+            NtTerminateProcess(GetCurrentProcess(), exit_code);
+        } else {
+            return server_abort_thread(exit_code);
+        }
+    }
+
+    status = NtTerminateThread( handle, exit_code );
+    if (status) SetLastError( RtlNtStatusToDosError(status) );
+    return !status;
+#endif
 }
 
 
diff -urN wine-1.0/dlls/kernel32/virtual.c wine-1.0-uk/dlls/kernel32/virtual.c
--- wine-1.0/dlls/kernel32/virtual.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/kernel32/virtual.c	2009-08-19 10:13:55.000000000 +0800
@@ -41,6 +41,7 @@
 #include "winerror.h"
 #include "wine/exception.h"
 #include "wine/debug.h"
+#include "handle.h"
 
 #include "kernel_private.h"
 
@@ -48,6 +49,24 @@
 
 static unsigned int page_size;
 
+#ifdef UNIFIED_KERNEL
+
+NTSTATUS WINAPI
+UkCreateSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+        const LARGE_INTEGER *size, ULONG protect,
+        ULONG sec_flags, HANDLE file );
+
+NTSTATUS WINAPI
+UkOpenSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr );
+
+NTSTATUS WINAPI
+UkMapViewOfSection( HANDLE handle, HANDLE process, PVOID *addr_ptr, ULONG zero_bits,
+        SIZE_T commit_size, const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr,
+        SECTION_INHERIT inherit, ULONG alloc_type, ULONG protect );
+
+NTSTATUS WINAPI
+UkUnmapViewOfSection( HANDLE process, PVOID addr );
+#endif
 
 /***********************************************************************
  *             VirtualAlloc   (KERNEL32.@)
@@ -402,7 +421,14 @@
     size.u.LowPart  = size_low;
     size.u.HighPart = size_high;
 
+#ifdef UNIFIED_KERNEL
     status = NtCreateSection( &ret, access, &attr, &size, protect, sec_type, hFile );
+#else
+    if ((hFile == INVALID_HANDLE_VALUE || !hFile) && attr.ObjectName)
+        status = UkCreateSection( &ret, access, &attr, &size, protect, sec_type, hFile );
+    else
+        status = NtCreateSection( &ret, access, &attr, &size, protect, sec_type, hFile );
+#endif
     if (status == STATUS_OBJECT_NAME_EXISTS)
         SetLastError( ERROR_ALREADY_EXISTS );
     else
@@ -467,7 +493,13 @@
 
     if (access == FILE_MAP_COPY) access = FILE_MAP_READ;
 
+#ifdef UNIFIED_KERNEL
     if ((status = NtOpenSection( &ret, access, &attr )))
+#else
+    if ((status = UkOpenSection( &ret, access, &attr )))
+        if (status == STATUS_OBJECT_NAME_NOT_FOUND)
+            if ((status = NtOpenSection( &ret, access, &attr )))
+#endif
     {
         SetLastError( RtlNtStatusToDosError(status) );
         ret = 0;
@@ -532,12 +564,26 @@
     else if (access & FILE_MAP_COPY) protect = PAGE_WRITECOPY;
     else protect = PAGE_NOACCESS;
 
+#ifdef UNIFIED_KERNEL
     if ((status = NtMapViewOfSection( handle, GetCurrentProcess(), &addr, 0, 0, &offset,
                                       &count, ViewShare, 0, protect )))
     {
         SetLastError( RtlNtStatusToDosError(status) );
         addr = NULL;
     }
+#else
+    if (IS_UK_HANDLE(handle))
+        status = UkMapViewOfSection( handle, GetCurrentProcess(), &addr, 0, 0, &offset,
+                &count, ViewShare, 0, protect );
+    else
+        status = NtMapViewOfSection( handle, GetCurrentProcess(), &addr, 0, 0, &offset,
+                &count, ViewShare, 0, protect );
+    if (status)
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        addr = NULL;
+    }
+#endif
     return addr;
 }
 
@@ -558,6 +604,9 @@
 BOOL WINAPI UnmapViewOfFile( LPCVOID addr )
 {
     NTSTATUS status = NtUnmapViewOfSection( GetCurrentProcess(), (void *)addr );
+#ifndef UNIFIED_KERNEL
+    if (status == STATUS_INVALID_PARAMETER) UkUnmapViewOfSection(GetCurrentProcess(), (void *)addr);
+#endif
     if (status) SetLastError( RtlNtStatusToDosError(status) );
     return !status;
 }
diff -urN wine-1.0/dlls/Makedll.rules.in wine-1.0-uk/dlls/Makedll.rules.in
--- wine-1.0/dlls/Makedll.rules.in	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/Makedll.rules.in	2009-08-19 10:30:46.000000000 +0800
@@ -8,11 +8,17 @@
 # plus all variables required by the global Make.rules.in
 #
 
+SLIBDIR     = /lib
+KERNELVER   = `uname -r | awk -F. '{print $$1}'`
+
 DLLFLAGS    = @DLLFLAGS@
 DLLEXT      = @DLLEXT@
 IMPLIBEXT   = @IMPLIBEXT@
 MINGWAR     = @MINGWAR@
-DEFS        = -D__WINESRC__ $(EXTRADEFS)
+LDRPATH     =
+DEFS        = -D__WINESRC__ $(EXTRADEFS) \
+              -DRUNTIME_LINKER=\"$(SLIBDIR)/ld-linux.so.$(KERNELVER)\" \
+              -DUNIFIED_KERNEL -DUNIFIED_KERNEL_EXESO
 BASEMODULE  = $(MODULE:%.dll=%)
 MAINSPEC    = $(BASEMODULE).spec
 SPEC_DEF    = $(BASEMODULE).def
@@ -32,7 +38,7 @@
 # Rules for .so files
 
 $(MODULE).so: $(MAINSPEC) $(ALL_OBJS) Makefile.in
-	$(WINEGCC) -B$(TOOLSDIR)/tools/winebuild -shared $(SRCDIR)/$(MAINSPEC) $(ALL_OBJS) $(EXTRADLLFLAGS) -o $@ $(DELAYIMPORTS:%=-l%) $(IMPORTS:%=-l%) $(DELAYIMPORTS:%=-Wb,-d%) $(ALL_LIBS)
+	$(WINEGCC) -B$(TOOLSDIR)/tools/winebuild -shared $(SRCDIR)/$(MAINSPEC) $(ALL_OBJS) $(EXTRADLLFLAGS) $(LDRPATH) -o $@ $(DELAYIMPORTS:%=-l%) $(IMPORTS:%=-l%) $(DELAYIMPORTS:%=-Wb,-d%) $(ALL_LIBS)
 
 # Rules for .dll files
 
diff -urN wine-1.0/dlls/ntdll/env.c wine-1.0-uk/dlls/ntdll/env.c
--- wine-1.0/dlls/ntdll/env.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/env.c	2009-08-19 10:13:54.000000000 +0800
@@ -33,6 +33,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(environ);
 
+#ifdef UNIFIED_KERNEL
+extern int get_child_socket_fd();
+#endif
 /******************************************************************************
  *  RtlCreateEnvironment		[NTDLL.@]
  */
@@ -427,6 +430,9 @@
     SIZE_T size, total_size;
     void *ptr;
     NTSTATUS status;
+#ifdef UNIFIED_KERNEL
+    int* psocketfd;
+#endif
 
     RtlAcquirePebLock();
     cur_params = NtCurrentTeb()->Peb->ProcessParameters;
@@ -454,6 +460,9 @@
             + Desktop->MaximumLength
             + ShellInfo->MaximumLength
             + RuntimeInfo->MaximumLength);
+#ifdef UNIFIED_KERNEL
+    size += sizeof(int); /* expand for socket fd */
+#endif
 
     total_size = size;
     ptr = NULL;
@@ -468,7 +477,13 @@
         params->Environment    = Environment;
         /* all other fields are zero */
 
+#ifndef UNIFIED_KERNEL
         ptr = params + 1;
+#else
+        psocketfd = ptr = params + 1; /* expand for socket fd */
+        *psocketfd = get_child_socket_fd();
+        ptr = (int *)ptr + 1;
+#endif
         append_unicode_string( &ptr, CurrentDirectoryName, &params->CurrentDirectory.DosPath );
         append_unicode_string( &ptr, DllPath, &params->DllPath );
         append_unicode_string( &ptr, ImagePathName, &params->ImagePathName );
diff -urN wine-1.0/dlls/ntdll/file.c wine-1.0-uk/dlls/ntdll/file.c
--- wine-1.0/dlls/ntdll/file.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/file.c	2009-08-19 10:23:36.000000000 +0800
@@ -87,6 +87,11 @@
 #define SECSPERDAY         86400
 #define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)SECSPERDAY)
 
+#ifdef UNIFIED_KERNEL
+extern NTSTATUS WINAPI
+NtWineService(struct __server_request_info * ReqMsg);
+#endif
+
 /**************************************************************************
  *                 NtOpenFile				[NTDLL.@]
  *                 ZwOpenFile				[NTDLL.@]
@@ -112,6 +117,26 @@
     return NtCreateFile( handle, access, attr, io, NULL, 0,
                          sharing, FILE_OPEN, options, NULL, 0 );
 }
+#ifdef UNIFIED_KERNEL
+/*
+ *      UkOpenFile
+ * We use UkOpenFile with the system call NtOpenFile interface to do the same things,
+ * but NtOpenFile in wine is used.
+ */
+NTSTATUS WINAPI UkOpenFile( PHANDLE handle, ACCESS_MASK access,
+                            POBJECT_ATTRIBUTES attr, PIO_STATUS_BLOCK io,
+                            ULONG sharing, ULONG options )
+{
+	NTSTATUS ret;
+	__asm__ __volatile__ (
+			"movl $0x58,%%eax\n\t"
+			"lea 8(%%ebp),%%edx\n\t"
+			"int $0x2E\n\t"
+			:"=a" (ret)
+			);
+	return ret;
+}
+#endif
 
 /**************************************************************************
  *		NtCreateFile				[NTDLL.@]
@@ -174,7 +199,11 @@
             req->sharing    = sharing;
             req->options    = options;
             wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+#ifndef UNIFIED_KERNEL
             io->u.Status = wine_server_call( req );
+#else
+            io->u.Status = NtWineService(req);
+#endif
             *handle = reply->handle;
         }
         SERVER_END_REQ;
@@ -218,7 +247,11 @@
             wine_server_add_data( req, &objattr, sizeof(objattr) );
             if (objattr.sd_len) wine_server_add_data( req, sd, objattr.sd_len );
             wine_server_add_data( req, unix_name.Buffer, unix_name.Length );
+#ifndef UNIFIED_KERNEL
             io->u.Status = wine_server_call( req );
+#else
+            io->u.Status = NtWineService(req);
+#endif
             *handle = reply->handle;
         }
         SERVER_END_REQ;
@@ -352,7 +385,9 @@
             break;
 
         result = read(fd, &fileio->buffer[fileio->already], fileio->count - fileio->already);
+#ifndef UNIFIED_KERNEL
         if (needs_close) close( fd );
+#endif
 
         if (result < 0)
         {
@@ -454,9 +489,15 @@
             {
                 req->handle = handle;
                 req->flags = 0;
+#ifndef UNIFIED_KERNEL
                 if (!(status = wine_server_call( req )) &&
                     reply->read_timeout != TIMEOUT_INFINITE)
                     timeouts->total = reply->read_timeout / -10000;
+#else
+                status = NtWineService(req);
+                if (!status && reply->read_timeout != TIMEOUT_INFINITE)
+                    timeouts->total = reply->read_timeout / -10000;
+#endif
             }
             SERVER_END_REQ;
         }
@@ -664,7 +705,11 @@
                 req->async.apc      = fileio_apc;
                 req->async.event    = hEvent;
                 req->async.cvalue   = cvalue;
+#ifndef UNIFIED_KERNEL
                 status = wine_server_call( req );
+#else
+                status = NtWineService(req);
+#endif
             }
             SERVER_END_REQ;
 
@@ -709,7 +754,9 @@
     if (cvalue) NTDLL_AddCompletion( hFile, cvalue, status, total );
 
 err:
+#ifndef UNIFIED_KERNEL
     if (needs_close) close( unix_handle );
+#endif
     if (status == STATUS_SUCCESS)
     {
         io_status->u.Status = status;
@@ -793,7 +840,9 @@
     if (cvalue) NTDLL_AddCompletion( file, cvalue, status, total );
 
  error:
+#ifndef UNIFIED_KERNEL
     if (needs_close) close( unix_handle );
+#endif
     if (status == STATUS_SUCCESS)
     {
         io_status->u.Status = status;
@@ -834,7 +883,9 @@
         else
             result = write( fd, &fileio->buffer[fileio->already], fileio->count - fileio->already );
 
+#ifndef UNIFIED_KERNEL
         if (needs_close) close( fd );
+#endif
 
         if (result < 0)
         {
@@ -987,7 +1038,11 @@
                 req->async.apc      = fileio_apc;
                 req->async.event    = hEvent;
                 req->async.cvalue   = cvalue;
+#ifndef UNIFIED_KERNEL
                 status = wine_server_call( req );
+#else
+                status = NtWineService(req);
+#endif
             }
             SERVER_END_REQ;
 
@@ -1030,7 +1085,9 @@
     if (cvalue) NTDLL_AddCompletion( hFile, cvalue, status, total );
 
 err:
+#ifndef UNIFIED_KERNEL
     if (needs_close) close( unix_handle );
+#endif
     if (status == STATUS_SUCCESS)
     {
         io_status->u.Status = status;
@@ -1119,7 +1176,9 @@
     if (cvalue) NTDLL_AddCompletion( file, cvalue, status, total );
 
  error:
+#ifndef UNIFIED_KERNEL
     if (needs_close) close( unix_handle );
+#endif
     if (status == STATUS_SUCCESS)
     {
         io_status->u.Status = status;
@@ -1159,7 +1218,11 @@
             req->handle   = async->handle;
             req->user_arg = async;
             wine_server_set_reply( req, async->buffer, async->size );
+#ifndef UNIFIED_KERNEL
             if (!(status = wine_server_call( req )))
+#else
+            if (!(status = NtWineService(req)))
+#endif
                 io->Information = wine_server_reply_size( reply );
         }
         SERVER_END_REQ;
@@ -1358,7 +1421,9 @@
             if (ioctl( fd, FIONREAD, &avail ) != 0)
             {
                 TRACE("FIONREAD failed reason: %s\n",strerror(errno));
+#ifndef UNIFIED_KERNEL
                 if (needs_close) close( fd );
+#endif
                 status = FILE_GetNtStatus();
                 break;
             }
@@ -1374,7 +1439,9 @@
                 ret = poll( &pollfd, 1, 0 );
                 if (ret == -1 || (ret == 1 && (pollfd.revents & (POLLHUP|POLLERR))))
                 {
+#ifndef UNIFIED_KERNEL
                     if (needs_close) close( fd );
+#endif
                     status = STATUS_PIPE_BROKEN;
                     break;
                 }
@@ -1394,7 +1461,9 @@
                     if (res >= 0) io->Information += res;
                 }
             }
+#ifndef UNIFIED_KERNEL
             if (needs_close) close( fd );
+#endif
         }
         break;
 
@@ -1672,7 +1741,11 @@
             {
                 req->handle = hFile;
                 req->flags = 0;
+#ifndef UNIFIED_KERNEL
                 io->u.Status = wine_server_call( req );
+#else
+                io->u.Status = NtWineService(req);
+#endif
                 if( io->u.Status == STATUS_SUCCESS )
                 {
                     info->MaximumMessageSize = reply->max_msgsize;
@@ -1696,7 +1769,9 @@
                         int res = recv( fd, tmpbuf, size, MSG_PEEK );
                         info->MessagesAvailable = (res > 0);
                         info->NextMessageSize = (res >= 0) ? res : MAILSLOT_NO_MESSAGE;
+#ifndef UNIFIED_KERNEL
                         if (needs_close) close( fd );
+#endif
                     }
                     RtlFreeHeap( GetProcessHeap(), 0, tmpbuf );
                 }
@@ -1710,7 +1785,11 @@
             SERVER_START_REQ( get_named_pipe_info )
             {
                 req->handle = hFile;
+#ifndef UNIFIED_KERNEL
                 if (!(io->u.Status = wine_server_call( req )))
+#else
+                if (!(io->u.Status = NtWineService(req)))
+#endif
                 {
                     pli->NamedPipeType = (reply->flags & NAMED_PIPE_MESSAGE_STREAM_WRITE) ? 
                         FILE_PIPE_TYPE_MESSAGE : FILE_PIPE_TYPE_BYTE;
@@ -1734,7 +1813,9 @@
         io->u.Status = STATUS_NOT_IMPLEMENTED;
         break;
     }
+#ifndef UNIFIED_KERNEL
     if (needs_close) close( fd );
+#endif
     if (io->u.Status == STATUS_SUCCESS && !io->Information) io->Information = info_sizes[class];
     return io->u.Status;
 }
@@ -1827,7 +1908,9 @@
                 }
             }
 
+#ifndef UNIFIED_KERNEL
             if (needs_close) close( fd );
+#endif
         }
         else io->u.Status = STATUS_INVALID_PARAMETER_3;
         break;
@@ -1843,7 +1926,9 @@
             if (lseek( fd, info->CurrentByteOffset.QuadPart, SEEK_SET ) == (off_t)-1)
                 io->u.Status = FILE_GetNtStatus();
 
+#ifndef UNIFIED_KERNEL
             if (needs_close) close( fd );
+#endif
         }
         else io->u.Status = STATUS_INVALID_PARAMETER_3;
         break;
@@ -1872,7 +1957,9 @@
             }
             io->u.Status = FILE_GetNtStatus();
 
+#ifndef UNIFIED_KERNEL
             if (needs_close) close( fd );
+#endif
         }
         else io->u.Status = STATUS_INVALID_PARAMETER_3;
         break;
@@ -1886,7 +1973,11 @@
                 req->handle = handle;
                 req->flags = MAILSLOT_SET_READ_TIMEOUT;
                 req->read_timeout = info->ReadTimeout.QuadPart;
+#ifndef UNIFIED_KERNEL
                 io->u.Status = wine_server_call( req );
+#else
+                io->u.Status = NtWineService(req);
+#endif
             }
             SERVER_END_REQ;
         }
@@ -1902,7 +1993,11 @@
                 req->handle   = handle;
                 req->chandle  = info->CompletionPort;
                 req->ckey     = info->CompletionKey;
+#ifndef UNIFIED_KERNEL
                 io->u.Status  = wine_server_call( req );
+#else
+                io->u.Status = NtWineService(req);
+#endif
             }
             SERVER_END_REQ;
         } else
@@ -2278,7 +2373,9 @@
         io->u.Status = STATUS_INVALID_PARAMETER;
         break;
     }
+#ifndef UNIFIED_KERNEL
     if (needs_close) close( fd );
+#endif
     return io->u.Status;
 }
 
@@ -2304,7 +2401,11 @@
     SERVER_START_REQ( flush_file )
     {
         req->handle = hFile;
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService(req);
+#endif
         hEvent = reply->event;
     }
     SERVER_END_REQ;
@@ -2348,7 +2449,11 @@
             req->count       = count->QuadPart;
             req->shared      = !exclusive;
             req->wait        = !dont_wait;
+#ifndef UNIFIED_KERNEL
             ret = wine_server_call( req );
+#else
+            ret = NtWineService(req);
+#endif
             handle = reply->handle;
             async  = reply->overlapped;
         }
@@ -2408,7 +2513,11 @@
         req->handle = hFile;
         req->offset = offset->QuadPart;
         req->count  = count->QuadPart;
+#ifndef UNIFIED_KERNEL
         status = wine_server_call( req );
+#else
+        status = NtWineService(req);
+#endif
     }
     SERVER_END_REQ;
     return status;
@@ -2495,7 +2604,11 @@
     SERVER_START_REQ( cancel_async )
     {
         req->handle = hFile;
+#ifndef UNIFIED_KERNEL
         wine_server_call( req );
+#else
+        NtWineService(req);
+#endif
     }
     SERVER_END_REQ;
     /* Let some APC be run, so that we can run the remaining APCs on hFile
@@ -2557,7 +2670,11 @@
         req->read_timeout = timeout.QuadPart;
         wine_server_add_data( req, attr->ObjectName->Buffer,
                               attr->ObjectName->Length );
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService(req);
+#endif
         if( ret == STATUS_SUCCESS )
             *pHandle = reply->handle;
     }
diff -urN wine-1.0/dlls/ntdll/init.c wine-1.0-uk/dlls/ntdll/init.c
--- wine-1.0/dlls/ntdll/init.c	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/init.c	2009-08-19 13:22:09.000000000 +0800
@@ -0,0 +1,733 @@
+/*
+ * init.c
+ *
+ * Copyright (C) 2006  Insigme Co., Ltd
+ *
+ * This software has been developed while working on the Linux Unified Kernel
+ * project (http://linux.insigma.com.cn) in the Insigma Research Institute,  
+ * which is a subdivision of Insigma Co., Ltd (http://www.insigma.com.cn).
+ * 
+ * The project is sponsored by Insigma Co., Ltd.
+ *
+ * The authors can be reached at linux@insigma.com.cn.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation; either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Revision History:
+ *   Jan 2006 - Created.
+ */
+ 
+/*
+ * init.c: initiliase all that should be done before LdrInitializThunk
+ */
+
+#ifdef UNIFIED_KERNEL
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <link.h>
+#include <elf.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdarg.h>
+#include <dlfcn.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winnt.h"
+#include "winternl.h"
+#include "wine/library.h"
+#include "wine/unicode.h"
+#include "wine/server.h"
+#include "wine/debug.h"
+
+#include "ntdll_misc.h"
+#include "handle.h"
+#include "wine/list.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(apc);
+
+#define	AT_BAK		1005
+static WCHAR *SystemDir = NULL;
+static WCHAR *WindowsDir = NULL;
+struct list handle_refer = LIST_INIT(handle_refer);
+static int handle_pairs;
+
+extern struct _KUSER_SHARED_DATA *user_shared_data;
+
+int child_socket_fd = 0;
+typedef struct _wine_modref
+{
+    LDR_MODULE            ldr;
+    int                   nDeps;
+    struct _wine_modref **deps;
+} WINE_MODREF;
+const char __dynamic_linker__[] __attribute__ ((section (".interp"))) = RUNTIME_LINKER;
+
+static PEB_LDR_DATA ldr;
+static RTL_BITMAP _tls_bitmap;
+static RTL_BITMAP _tls_expansion_bitmap;
+static RTL_BITMAP _fls_bitmap;
+extern int __wine_main_argc;
+extern char **__wine_main_argv;
+extern char **__wine_main_environ;
+extern unsigned long BaseProcessStartEntry;
+extern LIST_ENTRY tls_links;
+
+extern void debug_usage(void);
+extern void parse_options(const char *str);
+extern WINE_MODREF *alloc_module(HMODULE hModule, LPCWSTR filename);
+extern void server_init_process(void);
+extern size_t server_init_thread(int unix_pid, int unix_tid, void *entry_point);
+extern int __cxa_atexit (void (*func) (void *), void *arg, void *d);
+extern void build_dll_path(void);
+void _init(void);
+void StartInterp(PIO_APC_ROUTINE ApcRoutine, void *stack,
+        void *interp_start, unsigned long bak_addr, void *Context);
+extern void __wine_init_codepages(const union cptable *ansi, const union cptable *oem,
+        const union cptable *ucp);
+extern const union cptable *wine_cp_get_table(unsigned int codepage);
+extern NTSTATUS create_pe_sec_view(HANDLE hmodule);
+typedef void (*BaseProcessStartFunc)(unsigned long, void *);
+extern void uk_reserve_dos_area();
+
+ElfW(auxv_t) *auxvec;
+size_t auxvec_len;
+
+void set_child_socket_fd(int fd)
+{
+    child_socket_fd = fd;
+}
+
+int get_child_socket_fd()
+{
+    return child_socket_fd;
+}
+
+NTSTATUS  WINAPI NtContinue(PCONTEXT param0, BOOLEAN param1) 
+{
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0x15, %%eax\n\t"
+            "lea 8(%%ebp), %%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+}
+
+
+void ProcessStartForward(unsigned long start_address, void *peb)
+{
+    BaseProcessStartFunc	BaseProcessStart;
+
+    BaseProcessStart = (BaseProcessStartFunc)BaseProcessStartEntry;
+    BaseProcessStart(start_address, peb);
+}
+
+__attribute__ ((no_instrument_function)) void StartInterp();
+    /*
+     * StartInterp
+     *
+     * The linux interpreter here is used to link .so such as libwine.so for built-in dlls.
+     * ALl the dlls will be linked by ntdll.dll.so
+     */
+__asm__ (
+        ".globl StartInterp\n"
+        "StartInterp:\n\t"
+        "pusha\n\t"
+        "mov 0x28(%esp), %ecx\n\t"	/* stack top used for linux arg */
+        "sub %esp, %ecx\n\t"		/* stack size need backup */
+        "mov %esp, %esi\n\t"
+        "mov 0x30(%esp), %edi\n\t"
+        "mov %ecx, (%edi)\n\t"		/* backup the size */
+        "add $0x4, %edi\n\t"
+        "shr $2, %ecx\n\t"
+        "rep movsl\n\t"
+        "mov 0x28(%esp), %ecx\n\t"
+        "mov 0x2c(%esp), %esi\n\t"	/* Iosb, here in interpreter */
+        "mov %ecx, %esp\n\t"
+        "jmp *%esi\n"				/* _start in interpreter */
+        /* finally jmp to AT_ENTRY */
+
+        ".globl StartThunk\n"		/* set StartThunk to AT_ENTRY in kernel */
+        "StartThunk:\n\t"
+        "xorl %ebp, %ebp\n\t"		/* ABI need */
+        "movl (%esp), %esi\n\t"		/* Pop the argument count.  */
+        "leal 0x4(%esp), %ecx\n\t"		/* argv starts just at the current stack top.*/
+        "movl %esp, %ebp\n\t"
+        /* Before pushing the arguments align the stack to a 16-byte
+           (SSE needs 16-byte alignment) boundary to avoid penalties from
+           misaligned accesses. */
+        "andl $0xfffffff0, %esp\n\t"
+        "pushl %eax\n\t"	  /* push garbage */
+        "pushl %eax\n\t"	  /* push garbage */
+        "pushl %eax\n\t"	  /* push garbage */
+        "pushl %ebp\n\t"
+        "pushl %edx\n\t"      /* Push address of the shared library termination function. */
+        "pushl $0x0\n\t"      /* __libc_csu_init */
+        "pushl %ecx\n\t"      /* Push second argument: argv.  */
+        "pushl %esi\n\t"      /* Push first argument: argc.  */
+        "call PrepareThunk\n\t"
+        "movl (%esp), %esp\n\t"		/* restore %esp */
+        "movl (%eax), %ecx\n\t"		/* stack size backuped */
+        "leal 0x4(%eax), %esi\n\t"	/* stack data backuped in %esi */
+        "subl %ecx, %esp\n\t"		/* restore %esp */
+        "movl %esp, %edi\n\t"
+        "shrl $0x2, %ecx\n\t"
+        "rep movsl\n\t"				/* restore stack */
+        "popa\n\t"
+        "ret\n"						/* return from StartInterp */
+    );
+
+static unsigned long extra_page = 0;
+
+void __attribute__((stdcall, no_instrument_function))
+KiUserApcDispatcher(PIO_APC_ROUTINE ApcRoutine, void *ApcContext,
+        void *Iosb, unsigned long Reserved, void *Context)
+{
+    if (Reserved) {
+        extra_page = Reserved;
+        StartInterp(ApcRoutine, ApcContext, Iosb, Reserved, Context);
+    }
+
+    ApcRoutine(ApcContext, Iosb, Reserved);
+
+    /* switch back to the interrupted context */
+    NtContinue((PCONTEXT)Context, 1);
+}
+
+char *get_wine_bindir()
+{
+    char *wine_path, *bin_dir, *p, *temp;
+    char *paths = getenv("PATH");
+    char wine[] = "/wine";
+    struct stat st;
+    int path_len;
+
+    wine_path = malloc(MAX_PATH + sizeof(wine));
+    if (paths) {
+        paths = strdup(paths);
+        temp = paths;
+        for (p = paths; *p != 0; p++) {
+            while (*p != ':' && *p)
+                p++;
+            *p = 0;
+            strcpy(wine_path, temp);
+            strcat(wine_path, wine);
+
+            if (!stat(wine_path, &st))
+                if (S_ISREG(st.st_mode)) {
+                    path_len = strrchr(wine_path, '/') - wine_path;
+                    bin_dir = malloc((path_len + 1) * sizeof(char));
+                    memcpy(bin_dir, wine_path, path_len);
+                    bin_dir[path_len] = 0;
+                    free(paths);
+                    free(wine_path);
+                    return bin_dir;
+                }
+            temp = p + 1;
+        }
+        free(paths);
+    }
+    free(wine_path);
+    return NULL;
+}
+
+static NTSTATUS get_system_paths()
+{
+    static const WCHAR windirW[] = {'w','i','n','d','i','r',0};
+    static const WCHAR sysdirW[] = {'w','i','n','s','y','s','d','i','r',0};
+    static const WCHAR default_windirW[] = {'c',':','\\','w','i','n','d','o','w','s',0};
+    static const WCHAR default_sysdirW[] = {'\\','s','y','s','t','e','m','3','2',0};
+    UNICODE_STRING sys_value,win_value;
+    UNICODE_STRING sys_name,win_name;
+    int path_len = 0;
+
+    win_value.Length = 0;
+    win_value.MaximumLength = 0;
+    win_value.Buffer = NULL;
+    RtlInitUnicodeString(&win_name, windirW);
+    if (RtlQueryEnvironmentVariable_U(NULL, &win_name, &win_value) == STATUS_BUFFER_TOO_SMALL) {
+        path_len = win_value.Length;
+        win_value.MaximumLength = path_len + sizeof(WCHAR);
+        win_value.Buffer = RtlAllocateHeap(GetProcessHeap(), 0, win_value.MaximumLength);
+        if (!win_value.Buffer)
+            return STATUS_NO_MEMORY;
+
+        RtlQueryEnvironmentVariable_U(NULL, &win_name, &win_value);
+        win_value.Buffer[path_len / sizeof(WCHAR)] = 0;
+        WindowsDir = win_value.Buffer;
+    } else /* this could be happened with the STATUS_VARIABLE_NOT_FOUND */
+        WindowsDir = (WCHAR *)default_windirW;
+
+    sys_value.Length = 0;
+    sys_value.MaximumLength = 0;
+    sys_value.Buffer = NULL;
+    RtlInitUnicodeString(&sys_name, sysdirW);
+    if (RtlQueryEnvironmentVariable_U(NULL, &sys_name, &sys_value) == STATUS_BUFFER_TOO_SMALL) {
+        path_len = sys_value.Length;
+        sys_value.MaximumLength = path_len + sizeof(WCHAR);
+        sys_value.Buffer = RtlAllocateHeap(GetProcessHeap(), 0, sys_value.MaximumLength);
+        if (!sys_value.Buffer)
+            return STATUS_NO_MEMORY;
+
+        RtlQueryEnvironmentVariable_U(NULL, &sys_name, &sys_value);
+        sys_value.Buffer[path_len / sizeof(WCHAR)] = 0;
+        SystemDir = sys_value.Buffer;
+    } else { /* this could be happened with the STATUS_VARIABLE_NOT_FOUND */
+        path_len = strlenW(WindowsDir) * sizeof(WCHAR);
+        sys_value.Buffer = RtlAllocateHeap(GetProcessHeap(), 0, 
+                path_len + sizeof(default_sysdirW));
+        if (!sys_value.Buffer)
+            return STATUS_NO_MEMORY;
+
+        memcpy(sys_value.Buffer, WindowsDir, path_len);
+        memcpy(sys_value.Buffer + path_len / sizeof(WCHAR), default_sysdirW, 
+                sizeof(default_sysdirW));
+        SystemDir = sys_value.Buffer;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static WCHAR *get_dll_path(UNICODE_STRING* full_exe_name)
+{
+    LPWSTR exe_path, dll_path;
+    WCHAR* p;
+    int len = 0;
+    int exe_path_len = 0;
+
+    WCHAR SystemDir16[] = {'c',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m',0};
+    WCHAR CurrentDirW[] = {'.',0};
+
+    /* get the length:
+     * + exe path
+     * + system dll path:
+     *   + .
+     *   + 32-bit system path
+     *   + 16-bit system path
+     *   + windows path
+     * + PATH ? 
+     */
+    if (!full_exe_name)
+        exe_path = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    else
+        exe_path = full_exe_name->Buffer;
+    if (exe_path) {
+        exe_path_len = (strrchrW(exe_path, '\\') - exe_path);
+        len += exe_path_len + 1;
+    }
+
+    len += strlenW(CurrentDirW) + 1;
+
+    get_system_paths();
+
+    if (SystemDir)
+        len += strlenW(SystemDir) + 1;
+
+    len += strlenW(SystemDir16) + 1;
+
+    if (WindowsDir)
+        len += strlenW(WindowsDir) + 1;
+
+    /* make up dll path */
+    if ((p = dll_path = RtlAllocateHeap(GetProcessHeap(), 0, len * sizeof(WCHAR)))) {
+        /* exe path */
+        if (exe_path) {
+            memcpy(dll_path, exe_path, exe_path_len * sizeof(WCHAR));
+            p += exe_path_len;
+            *p++ = ';';
+        }
+
+        /* system dll path */
+        strcpyW(p, CurrentDirW);
+        p += strlenW(p);
+        *p++ = ';';
+        if (SystemDir) {
+            strcpyW(p, SystemDir);
+            p += strlenW(p);
+            *p++ = ';';
+        }
+        strcpyW(p, SystemDir16);
+        p += strlenW(p);
+        *p++ = ';';
+        if (WindowsDir) {
+            strcpyW(p, WindowsDir);
+            p += strlenW(p);
+            *p++ = ';';
+        }
+
+        /* PATH */
+        dll_path[len - 1] = 0;
+        return dll_path;
+    }
+
+    return NULL;
+}
+
+/* initialize all options at startup for Unified Kernel */
+void __debug_init(void)
+{
+    char *wine_debug;
+
+    if ((wine_debug = getenv("WINEDEBUG")))
+    {
+        if (!strcmp(wine_debug, "help")) debug_usage();
+        parse_options(wine_debug);
+    }
+}
+
+#define NORMALIZE(x, addr)   if (x) x = (typeof(x))((unsigned long)(x) + (unsigned long)(addr))
+#define NORMALIZE_PARAMS(params) \
+{ \
+    if ((params)) \
+    { \
+        NORMALIZE((params)->CurrentDirectory.DosPath.Buffer, (params)); \
+        NORMALIZE((params)->DllPath.Buffer, (params)); \
+        NORMALIZE((params)->ImagePathName.Buffer, (params)); \
+        NORMALIZE((params)->CommandLine.Buffer, (params)); \
+        NORMALIZE((params)->WindowTitle.Buffer, (params)); \
+        NORMALIZE((params)->Desktop.Buffer, (params)); \
+        NORMALIZE((params)->ShellInfo.Buffer, (params)); \
+        NORMALIZE((params)->RuntimeInfo.Buffer, (params)); \
+    } \
+}
+
+LPSTR WINAPI GetDir(void)
+{
+    static char *cmdlineA;  /* ASCII command line */
+    ANSI_STRING     ansi;
+
+    cmdlineA = (RtlUnicodeStringToAnsiString( &ansi, 
+                &NtCurrentTeb()->Peb->ProcessParameters->CurrentDirectory.DosPath, TRUE) == STATUS_SUCCESS) ?  
+        ansi.Buffer : NULL;
+
+    return cmdlineA;
+}
+
+/*
+ * init_for_load
+ * 
+ * Initializing all the parts that are done by wine-preloader
+ * All this initialization should be done before LdrInitializeThunk
+ */
+void init_for_load()
+{
+    WINE_MODREF *wm;
+    PEB *peb = NtCurrentTeb()->Peb;
+    RTL_USER_PROCESS_PARAMETERS *params = peb->ProcessParameters;
+    IMAGE_NT_HEADERS *nt = RtlImageNtHeader(peb->ImageBaseAddress);
+    WCHAR *dll_path = NULL;
+    ANSI_STRING func_name;
+    UNICODE_STRING fullname;
+    struct ntdll_thread_data *thread_data; 
+    struct ntdll_thread_regs *thread_regs; 
+    static struct debug_info debug_info;
+    int* psocketfd;
+    char socket_env[64];
+    void *addr;
+    SIZE_T size;
+
+    if (params && (unsigned long)params->CommandLine.Buffer < (unsigned long)params) {
+        NORMALIZE((params)->CurrentDirectory.DosPath.Buffer, (params));
+        NORMALIZE((params)->DllPath.Buffer, (params));
+        NORMALIZE((params)->ImagePathName.Buffer, (params));
+        NORMALIZE((params)->CommandLine.Buffer, (params));
+        NORMALIZE((params)->WindowTitle.Buffer, (params));
+        NORMALIZE((params)->Desktop.Buffer, (params));
+        NORMALIZE((params)->ShellInfo.Buffer, (params));
+        NORMALIZE((params)->RuntimeInfo.Buffer, (params));
+    }
+
+    addr = (void *)0x7ffe0000;
+    size = 0x10000;
+    NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE );
+    user_shared_data = addr;
+
+    /* signal */
+    thread_data = (struct ntdll_thread_data *)NtCurrentTeb()->SystemReserved2;
+    thread_regs = (struct ntdll_thread_regs *)NtCurrentTeb()->SpareBytes1;
+    thread_data->debug_info = &debug_info;
+    debug_info.str_pos = debug_info.strings;
+    debug_info.out_pos = debug_info.output;
+
+    thread_data->fs = 0;
+    asm("mov %%fs, %0\n" : "=m"(thread_data->fs));
+
+    get_signal_stack_total_size();
+
+    /* debug initialization for debug log*/
+    __debug_init();
+
+    /* initialize module lists */
+    InitializeListHead(&ldr.InLoadOrderModuleList);
+    InitializeListHead(&ldr.InMemoryOrderModuleList);
+    InitializeListHead(&ldr.InInitializationOrderModuleList);
+    NtCurrentTeb()->Peb->LdrData = &ldr;
+
+    /* initialize some fields in teb and peb */
+    NtCurrentTeb()->StaticUnicodeString.Length        = 0;
+    NtCurrentTeb()->StaticUnicodeString.Buffer        = NtCurrentTeb()->StaticUnicodeBuffer;
+    NtCurrentTeb()->StaticUnicodeString.MaximumLength = sizeof(NtCurrentTeb()->StaticUnicodeBuffer);
+
+    peb->TlsBitmap          = &_tls_bitmap;
+    peb->TlsExpansionBitmap = &_tls_expansion_bitmap;
+    peb->FlsBitmap          = &_fls_bitmap;
+    RtlInitializeBitMap(&_tls_bitmap, peb->TlsBitmapBits, sizeof(peb->TlsBitmapBits) * 8);
+    RtlInitializeBitMap(&_tls_expansion_bitmap, peb->TlsExpansionBitmapBits,
+            sizeof(peb->TlsExpansionBitmapBits) * 8);
+    RtlInitializeBitMap( &_fls_bitmap, peb->FlsBitmapBits, sizeof(peb->FlsBitmapBits) * 8 );
+
+    InitializeListHead(&tls_links);
+    InitializeListHead(&peb->FlsListHead);
+    InsertHeadList(&tls_links, &(NtCurrentTeb()->TlsLinks));
+
+    /* preset codepages before kernel32 being loaded */
+    __wine_init_codepages(wine_cp_get_table(1252),
+            wine_cp_get_table(437),
+            wine_cp_get_table(28591));
+
+    /* socket fd is located at the bottom of ppb*/
+    if (params) {
+        psocketfd = (int *)(params + 1);
+        if (*psocketfd) {
+            sprintf(socket_env, "WINESERVERSOCKET=%u", *psocketfd);
+            putenv(socket_env);
+        }
+    }
+
+    virtual_init_threading();
+
+    /* connect to the server */
+    server_init_process();
+    server_init_thread(getpid(), gettid(), NULL);
+
+    /* create process heap */
+    if (!(peb->ProcessHeap = RtlCreateHeap(HEAP_GROWABLE, NULL, 0, 0, NULL, NULL))) {
+        ERR("Error in create heap\n");
+        exit(1);
+    }
+
+    /* create view for main exe sections */
+    if (create_pe_sec_view(peb->ImageBaseAddress)) {
+        ERR("error in creating pe sections' views\n");
+        exit(1);
+    }
+
+    setenv("PWD",GetDir(),1);
+
+    /* allocate a module for main exe */
+    if (RtlSetCurrentDirectory_U(&params->CurrentDirectory.DosPath)) {
+        ERR( "error in setting current directory\n");
+        exit(1);
+    }
+
+    RtlDosPathNameToNtPathName_U(params->ImagePathName.Buffer, &fullname, NULL, NULL);
+    fullname.Buffer += 4; /* skip \??\ prefix */
+    fullname.Length -= 4;
+
+    /* initialize items in ppb */
+    params->wShowWindow = 1;
+
+    if (params->CommandLine.Buffer[0] == '.' && params->CommandLine.Buffer[1] == '/')
+        params->CommandLine.Buffer = params->CommandLine.Buffer + 2;
+
+    wm = alloc_module(peb->ImageBaseAddress, fullname.Buffer);
+    RtlFreeHeap(GetProcessHeap(), 0, fullname.Buffer);
+    if (!wm) {
+        ERR( "can't load %s\n", debugstr_w(fullname.Buffer));
+        exit(1);
+    }
+
+    /* set dll path */
+    dll_path = get_dll_path(&fullname);
+    RtlInitUnicodeString(&params->DllPath,dll_path);
+
+    /* register main exe on wine server */
+
+    SERVER_START_REQ(load_dll)
+    {
+        req->handle     = 0; /* no handle of main exe */
+        req->base       = peb->ImageBaseAddress;
+        req->size       = nt->OptionalHeader.SizeOfImage;
+        req->dbg_offset = nt->FileHeader.PointerToSymbolTable;
+        req->dbg_size   = nt->FileHeader.NumberOfSymbols;
+        req->name       = &wm->ldr.FullDllName.Buffer;
+        wine_server_add_data(req, wm->ldr.FullDllName.Buffer, wm->ldr.FullDllName.Length);
+        wine_server_call(req);
+    }
+    SERVER_END_REQ;
+}
+
+__attribute__((stdcall))
+int PrepareThunk(
+            int argc,
+            char **argv,
+            void (*init) (void),
+            void (*rtld_fini)(void))
+{
+    char	**evp, **p;
+    char 	*wine_path, *bin_dir;
+    char	wine[] = "/wine";
+
+    if (__builtin_expect (rtld_fini != NULL, 1))
+        __cxa_atexit ((void (*) (void *)) rtld_fini, NULL, NULL);
+
+    p = evp = argv + argc + 1;
+
+    while (*p++) ;
+    auxvec = (ElfW(auxv_t) *)p;
+    auxvec_len = (unsigned long)argv[0] - (unsigned long)p;
+
+    bin_dir = get_wine_bindir();
+    wine_path = malloc(strlen(bin_dir) + sizeof(wine));
+    strcpy(wine_path, bin_dir);
+    strcat(wine_path, wine);
+    free(bin_dir);
+
+    wine_init_argv0_path(wine_path);
+    build_dll_path();
+    __wine_main_argc = argc;
+    __wine_main_argv = argv;
+    __wine_main_environ = evp;
+    free(wine_path);
+
+    init_for_load();
+
+    /* Call the initializer of the program, if any.  */
+    if (init)
+        (*init)();
+
+    /* .init in ntdll.dll.so */
+    _init();
+    NtCurrentTeb()->Peb->ProcessParameters->Environment = NULL;
+    return extra_page;
+}
+
+int store_handle_pair(HANDLE uk_handle, HANDLE wine_handle)
+{
+    struct handle_pair *pair = malloc(sizeof(struct handle_pair));
+
+    if (!pair)
+        return 0;
+
+    pair->uk_handle = uk_handle;
+    pair->wine_handle = wine_handle;
+    list_add_before(&handle_refer, &pair->entry);
+
+    return ++handle_pairs;
+}
+
+struct handle_pair* search_handle_pair(HANDLE uk_handle)
+{
+    struct list* p;
+
+    LIST_FOR_EACH(p, &handle_refer)
+    {
+        struct handle_pair* pair = LIST_ENTRY(p, struct handle_pair,entry);
+        if (pair->uk_handle == uk_handle)
+            return pair;
+    }
+    return NULL;
+}
+
+void delete_handle_pair(struct handle_pair* pair)
+{
+    list_remove(&pair->entry);
+    free(pair);
+    handle_pairs--;
+}
+
+#ifdef UNIFIED_KERNEL_EXESO
+int UkDebug(unsigned long arg1, unsigned long arg2, unsigned long arg3)
+{
+    int ret;
+    __asm__ __volatile__(
+            "movl $234,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+}
+
+IMAGE_NT_HEADERS **get_main_exe_ptr();
+void *map_dll( const IMAGE_NT_HEADERS *nt_descr );
+
+void __attribute__((regparm(0)))
+ntdll_start_thunk(int unknown)
+{
+    int *pargc = (int *)&unknown - 1;
+    char **argv = (char **)&unknown;
+    void *exeso;
+    void *image_base;
+    PEB *peb = NtCurrentTeb()->Peb;
+    IMAGE_NT_HEADERS **nt;
+    void *entry;
+    char *pipe = NULL;
+    int fd;
+    RTL_USER_PROCESS_PARAMETERS *params = NtCurrentTeb()->Peb->ProcessParameters;
+    const char *env_socket = getenv("WINESERVERSOCKET");
+    int socket_fd = 0, *psocketfd;
+
+    uk_reserve_dos_area();
+    exeso = dlopen(argv[0], RTLD_NOW);
+    if(!exeso)
+        ERR("dlopen exeso failed: %s\n", dlerror());
+
+    nt = get_main_exe_ptr();
+    entry = (void *)(*nt)->OptionalHeader.AddressOfEntryPoint;
+    image_base = map_dll(*nt);
+    peb->ImageBaseAddress = image_base;
+    *nt = 0;
+
+    if (env_socket)
+        socket_fd = atoi(env_socket);
+
+    PrepareThunk(*pargc, argv, 0, 0);
+    /* 
+     * set socket fd to the bottom of ppb
+     * For built-in exe, we don't get the socket fd from ppb, 
+     * and we set it here just for the further check
+     */
+    psocketfd = params + 1; /* expand for socket fd */
+    *psocketfd = socket_fd;
+
+    pipe = getenv("PIDTIDPIPE");
+    if(pipe) {
+        HANDLE pid, tid;
+        /* retrive of pid/tid should be after init_for_load() */
+        pid = NtCurrentTeb()->ClientId.UniqueProcess;
+        tid = NtCurrentTeb()->ClientId.UniqueThread;
+        fd = atoi(pipe);
+        write(fd, &pid, sizeof(pid));
+        write(fd, &tid, sizeof(tid));
+    }
+
+    LdrInitializeThunk(0,0,0,0);
+
+    asm __volatile__ ("movl %0, %%esp\n\t"
+            "pushl $0x7ffdf000\n\t"
+            "pushl %1\n\t"
+            "pushl $0xdeadbeef\n\t"
+            "jmp *%2\n\t"
+            :: "r"(pargc), "r"(entry),
+            "r"(&ProcessStartForward)
+            );
+
+    exit(0);
+}
+
+    void __attribute__((regparm(0)))
+exeso_start_thunk(int unknown)
+{
+    UkDebug(0, 0, 0);
+}
+#endif
+
+#endif
diff -urN wine-1.0/dlls/ntdll/ld.s wine-1.0-uk/dlls/ntdll/ld.s
--- wine-1.0/dlls/ntdll/ld.s	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/ld.s	2009-08-18 16:11:13.000000000 +0800
@@ -0,0 +1,182 @@
+/* Script for --shared -z combreloc: shared library, combine & sort relocs */
+OUTPUT_FORMAT("elf32-i386", "elf32-i386",
+	      "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(_start)
+SEARCH_DIR("/usr/i386-redhat-linux/lib"); SEARCH_DIR("/usr/local/lib"); SEARCH_DIR("/lib"); SEARCH_DIR("/usr/lib");
+/* Do we need any of these for elf?
+   __DYNAMIC = 0;    */
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  . = 0x77fd0000 + SIZEOF_HEADERS;
+  .hash           : { *(.hash) }
+  .dynsym         : { *(.dynsym) }
+  .dynstr         : { *(.dynstr) }
+  .gnu.version    : { *(.gnu.version) }
+  .gnu.version_d  : { *(.gnu.version_d) }
+  .gnu.version_r  : { *(.gnu.version_r) }
+  .rel.dyn        :
+    {
+      *(.rel.init)
+      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)
+      *(.rel.fini)
+      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)
+      *(.rel.data.rel.ro*)
+      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)
+      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)
+      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)
+      *(.rel.ctors)
+      *(.rel.dtors)
+      *(.rel.got)
+      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)
+    }
+  .rela.dyn       :
+    {
+      *(.rela.init)
+      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)
+      *(.rela.fini)
+      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)
+      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)
+      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)
+      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)
+      *(.rela.ctors)
+      *(.rela.dtors)
+      *(.rela.got)
+      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)
+    }
+  .rel.plt        : { *(.rel.plt) }
+  .rela.plt       : { *(.rela.plt) }
+  .init           :
+  {
+    KEEP (*(.init))
+  } =0x90909090
+  .plt            : { *(.plt) }
+  .text           :
+  {
+    *(.text .stub .text.* .gnu.linkonce.t.*)
+    KEEP (*(.text.*personality*))
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+  } =0x90909090
+  .fini           :
+  {
+    KEEP (*(.fini))
+  } =0x90909090
+  PROVIDE (__etext = .);
+  PROVIDE (_etext = .);
+  PROVIDE (etext = .);
+  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
+  .rodata1        : { *(.rodata1) }
+  .eh_frame_hdr : { *(.eh_frame_hdr) }
+  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) }
+  .gcc_except_table   : ONLY_IF_RO { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }
+  /* Adjust the address for the data segment.  We want to adjust up to
+     the same address within the page on the next page up.  */
+  . = ALIGN (0x1000) - ((0x1000 - .) & (0x1000 - 1)); . = DATA_SEGMENT_ALIGN (0x1000, 0x1000);
+  /* Exception handling  */
+  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) }
+  .gcc_except_table   : ONLY_IF_RW { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }
+  /* Thread Local Storage sections  */
+  .tdata	  : { *(.tdata .tdata.* .gnu.linkonce.td.*) }
+  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }
+  /* Ensure the __preinit_array_start label is properly aligned.  We
+     could instead move the label definition inside the section, but
+     the linker would then create the section even if it turns out to
+     be empty, which isn't pretty.  */
+  . = ALIGN(32 / 8);
+  .preinit_array     : { KEEP (*(.preinit_array)) }
+  .init_array     : { KEEP (*(.init_array)) }
+  .fini_array     : { KEEP (*(.fini_array)) }
+  .ctors          :
+  {
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin*.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE (*crtend*.o ) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+  }
+  .dtors          :
+  {
+    KEEP (*crtbegin*.o(.dtors))
+    KEEP (*(EXCLUDE_FILE (*crtend*.o ) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+  }
+  .jcr            : { KEEP (*(.jcr)) }
+  .data.rel.ro : { *(.data.rel.ro.local) *(.data.rel.ro*) }
+  .dynamic        : { *(.dynamic) }
+  .got            : { *(.got) }
+  . = DATA_SEGMENT_RELRO_END (12, .);
+  .got.plt        : { *(.got.plt) }
+  .data           :
+  {
+    *(.data .data.* .gnu.linkonce.d.*)
+    KEEP (*(.gnu.linkonce.d.*personality*))
+    SORT(CONSTRUCTORS)
+  }
+  .data1          : { *(.data1) }
+  _edata = .;
+  PROVIDE (edata = .);
+  __bss_start = .;
+  .bss            :
+  {
+   *(.dynbss)
+   *(.bss .bss.* .gnu.linkonce.b.*)
+   *(COMMON)
+   /* Align here to ensure that the .bss section occupies space up to
+      _end.  Align after .bss to ensure correct alignment even if the
+      .bss section disappears because there are no input sections.  */
+   . = ALIGN(32 / 8);
+  }
+  . = ALIGN(32 / 8);
+  _end = .;
+  PROVIDE (end = .);
+  . = DATA_SEGMENT_END (.);
+  /* Stabs debugging sections.  */
+  .stab          0 : { *(.stab) }
+  .stabstr       0 : { *(.stabstr) }
+  .stab.excl     0 : { *(.stab.excl) }
+  .stab.exclstr  0 : { *(.stab.exclstr) }
+  .stab.index    0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment       0 : { *(.comment) }
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+  /DISCARD/ : { *(.note.GNU-stack) }
+}
diff -urN wine-1.0/dlls/ntdll/loader.c wine-1.0-uk/dlls/ntdll/loader.c
--- wine-1.0/dlls/ntdll/loader.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/loader.c	2009-08-19 10:23:40.000000000 +0800
@@ -52,6 +52,15 @@
 WINE_DECLARE_DEBUG_CHANNEL(loaddll);
 WINE_DECLARE_DEBUG_CHANNEL(imports);
 
+#ifdef UNIFIED_KERNEL
+static int is_ntdll = 1;
+unsigned long BaseProcessStartEntry;
+unsigned long BaseThreadStartEntry;
+
+BOOL (* process_init)(void);
+void (* PTHREAD_Init)(void);
+void (*ThreadStartup)(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter);
+#endif
 /* we don't want to include winuser.h */
 #define RT_MANIFEST                         ((ULONG_PTR)24)
 #define ISOLATIONAWARE_MANIFEST_RESOURCE_ID ((ULONG_PTR)2)
@@ -687,7 +696,11 @@
  * Allocate a WINE_MODREF structure and add it to the process list
  * The loader_section must be locked while calling this function.
  */
+#ifndef UNIFIED_KERNEL
 static WINE_MODREF *alloc_module( HMODULE hModule, LPCWSTR filename )
+#else
+WINE_MODREF *alloc_module( HMODULE hModule, LPCWSTR filename )
+#endif
 {
     WINE_MODREF *wm;
     const WCHAR *p;
@@ -1333,10 +1346,21 @@
         builtin_load_info->status = STATUS_INVALID_IMAGE_FORMAT;
         return;
     }
+#ifndef UNIFIED_KERNEL
     addr = module;
     size = nt->OptionalHeader.SizeOfImage;
     NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &size,
                              MEM_SYSTEM | MEM_IMAGE, PAGE_EXECUTE_WRITECOPY );
+#else
+    if (is_ntdll)
+        is_ntdll = 0;
+    else {
+        addr = module;
+        size = nt->OptionalHeader.SizeOfImage;
+        NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &size,
+                MEM_SYSTEM | MEM_IMAGE, PAGE_EXECUTE_WRITECOPY );
+    } 
+#endif
     /* create the MODREF */
 
     if (!(fullname = get_builtin_fullname( builtin_load_info->filename, filename )))
@@ -2350,6 +2374,67 @@
     return ret;
 }
 
+#ifdef UNIFIED_KERNEL
+/*
+ * get loaded dll's handle
+ */
+void *get_dll_handle(char *dll_name)
+{
+    WCHAR module_name[32];
+    PLIST_ENTRY mark, entry;
+    PLDR_MODULE mod;
+    int len = strlen(dll_name);
+
+    if (len * sizeof(WCHAR) < sizeof(module_name)) {
+        ascii_to_unicode(module_name, dll_name, len );
+        module_name[len] = 0;
+
+        if (cached_modref && !strcmpiW(module_name, cached_modref->ldr.FullDllName.Buffer))
+            return cached_modref->ldr.SectionHandle;
+
+        mark = &NtCurrentTeb()->Peb->LdrData->InMemoryOrderModuleList;
+        for (entry = mark->Flink; entry != mark; entry = entry->Flink) {
+            mod = CONTAINING_RECORD(entry, LDR_MODULE, InMemoryOrderModuleList);
+            if (!strcmpiW(module_name, mod->FullDllName.Buffer)) {
+                cached_modref = CONTAINING_RECORD(mod, WINE_MODREF, ldr);
+                return mod->SectionHandle;
+            }
+        }
+        return NULL;
+    } else {
+        WCHAR *ptr = RtlAllocateHeap(GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR));
+        if (!ptr) return NULL;
+        ascii_to_unicode(ptr, dll_name, len);
+        ptr[len] = 0;
+
+        if (cached_modref && !strcmpiW(ptr, cached_modref->ldr.FullDllName.Buffer))
+            return cached_modref->ldr.SectionHandle;
+
+        mark = &NtCurrentTeb()->Peb->LdrData->InMemoryOrderModuleList;
+        for (entry = mark->Flink; entry != mark; entry = entry->Flink) {
+            mod = CONTAINING_RECORD(entry, LDR_MODULE, InMemoryOrderModuleList);
+            if (!strcmpiW(ptr, mod->FullDllName.Buffer)) {
+                cached_modref = CONTAINING_RECORD(mod, WINE_MODREF, ldr);
+                return mod->SectionHandle;
+            }
+        }
+        RtlFreeHeap( GetProcessHeap(), 0, ptr );
+        return NULL;
+    }
+}
+
+/*
+ * find symbol in loaded builtin dll
+ */
+void *find_builtin_symbol(const char *dll_name, const char *symbol)
+{
+    void *dll_handle = get_dll_handle((char *)dll_name);
+    char error[1024];
+    int err_size = sizeof(error);
+
+    return wine_dlsym(dll_handle, symbol, error, err_size);
+}
+#endif
 
 /***********************************************************************
  *           attach_process_dlls
@@ -2360,7 +2445,11 @@
 {
     NTSTATUS status;
 
+#ifndef UNIFIED_KERNEL
     pthread_functions.sigprocmask( SIG_UNBLOCK, &server_block_set, NULL );
+#else
+    sigprocmask( SIG_UNBLOCK, &server_block_set, NULL );
+#endif
 
     RtlEnterCriticalSection( &loader_section );
     if ((status = process_attach( wm, (LPVOID)1 )) != STATUS_SUCCESS)
@@ -2389,6 +2478,10 @@
     PEB *peb = NtCurrentTeb()->Peb;
     IMAGE_NT_HEADERS *nt = RtlImageNtHeader( peb->ImageBaseAddress );
 
+#ifdef UNIFIED_KERNEL
+    wine_dll_set_callback(load_builtin_callback);
+    main_exe_file = 0;
+#endif
     if (main_exe_file) NtClose( main_exe_file );  /* at this point the main module is created */
 
     /* allocate the modref for the main exe (if not already done) */
@@ -2411,22 +2504,49 @@
     stack_size = max( nt->OptionalHeader.SizeOfStackReserve, nt->OptionalHeader.SizeOfStackCommit );
     if (stack_size < 1024 * 1024) stack_size = 1024 * 1024;  /* Xlib needs a large stack */
 
+#ifndef UNIFIED_KERNEL
     if ((status = virtual_alloc_thread_stack( NULL, stack_size )) != STATUS_SUCCESS) goto error;
+#endif
     if ((status = server_init_process_done()) != STATUS_SUCCESS) goto error;
 
+#ifndef UNIFIED_KERNEL
     actctx_init();
+#endif
     load_path = NtCurrentTeb()->Peb->ProcessParameters->DllPath.Buffer;
     if ((status = fixup_imports( wm, load_path )) != STATUS_SUCCESS) goto error;
+#ifdef UNIFIED_KERNEL
+    /* get process start address from kernel32.dll*/
+    if (!(BaseProcessStartEntry = (unsigned long) find_builtin_symbol("kernel32.dll", "BaseProcessStart")))
+            goto error;
+
+    if (!(process_init = find_builtin_symbol("kernel32.dll", "process_init")))
+            goto error;
+    
+    if (!(ThreadStartup = find_builtin_symbol("kernel32.dll", "ThreadStartup")))
+            goto error;
+    
+    if (!(unhandled_exception_filter = find_builtin_symbol("kernel32.dll", "UnhandledExceptionFilter")))
+            goto error;
+
+
+    process_init();
+    actctx_init();
+#endif
     if ((status = alloc_process_tls()) != STATUS_SUCCESS) goto error;
     if ((status = alloc_thread_tls()) != STATUS_SUCCESS) goto error;
 
+#ifndef UNIFIED_KERNEL
     status = wine_call_on_stack( attach_process_dlls, wm, NtCurrentTeb()->Tib.StackBase );
+#endif
+    status = attach_process_dlls(wm);
     if (status != STATUS_SUCCESS) goto error;
 
+#ifndef UNIFIED_KERNEL
     /* clear the stack contents before calling the main entry point, some broken apps need that */
     wine_anon_mmap( NtCurrentTeb()->Tib.StackLimit,
                     (char *)NtCurrentTeb()->Tib.StackBase - (char *)NtCurrentTeb()->Tib.StackLimit,
                     PROT_READ | PROT_WRITE, MAP_FIXED );
+#endif
 
     if (nt->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE) VIRTUAL_UseLargeAddressSpace();
     return;
@@ -2560,6 +2680,10 @@
 {
     PLIST_ENTRY mark, entry;
     LPWSTR buffer, p;
+#ifdef UNIFIED_KERNEL
+    WCHAR kernel32[] = {'k', 'e', 'r', 'n', 'e', 'l', '3', '2', '.' ,'d' ,'l' ,'l' , '\0'};
+    WCHAR ntdll[] = {'n', 't', 'd', 'l', 'l', '.', 'd', 'l', 'l', '\0'};
+#endif
 
     RtlCreateUnicodeString( &windows_dir, windir );
     RtlCreateUnicodeString( &system_dir, sysdir );
@@ -2571,6 +2695,12 @@
     {
         LDR_MODULE *mod = CONTAINING_RECORD( entry, LDR_MODULE, InLoadOrderModuleList );
 
+#ifdef UNIFIED_KERNEL
+        /* this should be done just for kernel32.dll and ntdll.dll */
+        if (strcmpiW(mod->BaseDllName.Buffer, kernel32)
+                && strcmpiW(mod->BaseDllName.Buffer, ntdll))
+            continue;
+#endif
         assert( mod->Flags & LDR_WINE_INTERNAL );
 
         buffer = RtlAllocateHeap( GetProcessHeap(), 0,
diff -urN wine-1.0/dlls/ntdll/Makefile.in wine-1.0-uk/dlls/ntdll/Makefile.in
--- wine-1.0/dlls/ntdll/Makefile.in	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/Makefile.in	2009-08-18 16:11:13.000000000 +0800
@@ -5,7 +5,7 @@
 VPATH     = @srcdir@
 MODULE    = ntdll.dll
 IMPORTLIB = ntdll
-EXTRALIBS = @IOKITLIB@
+EXTRALIBS = @IOKITLIB@-ldl -lpthread
 EXTRADLLFLAGS = -Wl,--image-base,0x7bc00000
 
 C_SRCS = \
@@ -51,13 +51,15 @@
 	time.c \
 	version.c \
 	virtual.c \
-	wcstring.c
+	wcstring.c \
+	init.c
 
 RC_SRCS = version.rc
 
 EXTRA_OBJS = relay32.o
 
 @MAKE_DLL_RULES@
+LDRPATH += -Wl,--script,ld.s
 
 relay32.o: $(WINEBUILD)
 	$(WINEBUILD) $(WINEBUILDFLAGS) -o $@ --relay32
diff -urN wine-1.0/dlls/ntdll/nt.c wine-1.0-uk/dlls/ntdll/nt.c
--- wine-1.0/dlls/ntdll/nt.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/nt.c	2009-08-19 10:22:26.000000000 +0800
@@ -36,6 +36,9 @@
 #include "winternl.h"
 #include "ntdll_misc.h"
 #include "wine/server.h"
+#ifdef UNIFIED_KERNEL
+#include "handle.h"
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
@@ -98,6 +101,7 @@
 {
     NTSTATUS ret;
 
+#ifndef UNIFIED_KERNEL
     TRACE("(%p,0x%08x,%p)\n", ProcessHandle,DesiredAccess, TokenHandle);
 
     SERVER_START_REQ( open_token )
@@ -110,6 +114,28 @@
         if (!ret) *TokenHandle = reply->token;
     }
     SERVER_END_REQ;
+#else
+    struct handle_pair* pair;
+
+    TRACE("(%p,0x%08x,%p)\n", ProcessHandle,DesiredAccess, TokenHandle);
+    
+    SERVER_START_REQ( open_token )
+    {
+        if ((ProcessHandle != GetCurrentProcess())) {
+            if ((pair = search_handle_pair(ProcessHandle)))
+                req->handle = pair->wine_handle;
+            else
+                req->handle = NULL;
+        } else
+            req->handle = ProcessHandle;
+        req->access     = DesiredAccess;
+        req->attributes = 0;
+        req->flags      = 0;
+        ret = wine_server_call( req );
+        if (!ret) *TokenHandle = reply->token;
+    }
+    SERVER_END_REQ;
+#endif
 
     return ret;
 }
@@ -126,6 +152,7 @@
 {
     NTSTATUS ret;
 
+#ifndef UNIFIED_KERNEL
     TRACE("(%p,0x%08x,0x%08x,%p)\n",
           ThreadHandle,DesiredAccess, OpenAsSelf, TokenHandle);
 
@@ -140,6 +167,32 @@
         if (!ret) *TokenHandle = reply->token;
     }
     SERVER_END_REQ;
+#else
+    struct handle_pair* pair;
+
+    TRACE("(%p,0x%08x,0x%08x,%p)\n",
+            ThreadHandle,DesiredAccess, OpenAsSelf, TokenHandle);
+
+    SERVER_START_REQ( open_token )
+    {
+        if ((ThreadHandle != (HANDLE) GetCurrentThread()))
+        {
+            if ((pair = search_handle_pair(ThreadHandle)))
+                req->handle = pair->wine_handle;
+            else
+                req->handle = NULL;
+        }
+        else
+            req->handle = ThreadHandle;
+        req->access     = DesiredAccess;
+        req->attributes = 0;
+        req->flags      = OPEN_TOKEN_THREAD;
+        if (OpenAsSelf) req->flags |= OPEN_TOKEN_AS_SELF;
+        ret = wine_server_call( req );
+        if (!ret) *TokenHandle = reply->token;
+    }
+    SERVER_END_REQ;
+#endif
 
     return ret;
 }
diff -urN wine-1.0/dlls/ntdll/ntdll_misc.h wine-1.0-uk/dlls/ntdll/ntdll_misc.h
--- wine-1.0/dlls/ntdll/ntdll_misc.h	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/ntdll_misc.h	2009-08-18 16:11:13.000000000 +0800
@@ -67,10 +67,17 @@
 extern void server_init_process(void);
 extern NTSTATUS server_init_process_done(void);
 extern size_t server_init_thread( int unix_pid, int unix_tid, void *entry_point );
+#ifndef UNIFIED_KERNEL
 extern void DECLSPEC_NORETURN server_protocol_error( const char *err, ... );
 extern void DECLSPEC_NORETURN server_protocol_perror( const char *err );
 extern void DECLSPEC_NORETURN server_exit_thread( int status );
 extern void DECLSPEC_NORETURN server_abort_thread( int status );
+#else
+extern void server_protocol_error( const char *err, ... );
+extern void server_protocol_perror( const char *err );
+extern void server_exit_thread( int status );
+extern int server_abort_thread( int status );
+#endif
 extern sigset_t server_block_set;
 extern void server_enter_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset );
 extern void server_leave_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset );
diff -urN wine-1.0/dlls/ntdll/ntdll.spec wine-1.0-uk/dlls/ntdll/ntdll.spec
--- wine-1.0/dlls/ntdll/ntdll.spec	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/ntdll.spec	2009-08-18 16:11:13.000000000 +0800
@@ -134,7 +134,7 @@
 @ stdcall NtCreateNamedPipeFile(ptr long ptr ptr long long long long long long long long long ptr)
 @ stdcall NtCreatePagingFile(long long long long)
 @ stdcall NtCreatePort(ptr ptr long long ptr)
-@ stub NtCreateProcess
+# @ stub NtCreateProcess
 # @ stub NtCreateProcessEx
 @ stub NtCreateProfile
 @ stdcall NtCreateSection(ptr long ptr ptr long long long)
@@ -1392,3 +1392,32 @@
 @ cdecl wine_nt_to_unix_file_name(ptr ptr long long)
 @ cdecl wine_unix_to_nt_file_name(ptr ptr)
 @ cdecl __wine_init_windows_dir(wstr wstr)
+
+# Linux Unified Kernel extensions
+# All functions are modified from ReactOS
+
+# Thread
+@ cdecl RtlRosCreateUserThread(long ptr long long ptr ptr ptr ptr ptr long long)
+
+# Attributes
+@ cdecl RtlRosR32AttribsToNativeAttribs(ptr ptr)
+
+# Process
+@ stdcall NtCreateProcess(long long ptr long long long long long)
+
+# Section
+  # system call NtOpenFile
+@ stdcall UkCreateSection(ptr long ptr ptr long long long)
+@ stdcall UkOpenSection(ptr long ptr )
+@ stdcall UkMapViewOfSection(ptr ptr ptr long long ptr ptr long long long)
+@ stdcall UkUnmapViewOfSection(ptr ptr)
+@ stdcall UkQuerySection(ptr long ptr long ptr)
+
+@ stdcall UkOpenFile(ptr long ptr ptr long long)
+
+@ stdcall set_child_socket_fd(long)
+@ stdcall get_child_socket_fd()
+@ stdcall store_handle_pair(long long)
+@ stdcall search_handle_pair(long)
+@ stdcall delete_handle_pair(ptr)
+@ stdcall server_abort_thread(long)
diff -urN wine-1.0/dlls/ntdll/om.c wine-1.0-uk/dlls/ntdll/om.c
--- wine-1.0/dlls/ntdll/om.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/om.c	2009-08-19 10:22:52.000000000 +0800
@@ -38,6 +38,9 @@
 #include "winternl.h"
 #include "ntdll_misc.h"
 #include "wine/server.h"
+#ifdef UNIFIED_KERNEL
+#include "handle.h"
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
@@ -59,6 +62,7 @@
     TRACE("(%p,0x%08x,%p,0x%08x,%p): stub\n",
           handle, info_class, ptr, len, used_len);
 
+#ifndef UNIFIED_KERNEL
     if (used_len) *used_len = 0;
 
     switch (info_class)
@@ -112,6 +116,73 @@
         status = STATUS_NOT_IMPLEMENTED;
         break;
     }
+#else
+    if (!IS_UK_HANDLE(handle))
+    {
+        if (used_len) *used_len = 0;
+
+        switch (info_class)
+        {
+            case ObjectBasicInformation:
+                {
+                    POBJECT_BASIC_INFORMATION p = (POBJECT_BASIC_INFORMATION)ptr;
+
+                    if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
+
+                    SERVER_START_REQ( get_object_info )
+                    {
+                        req->handle = handle;
+                        status = wine_server_call( req );
+                        if (status == STATUS_SUCCESS)
+                        {
+                            memset( p, 0, sizeof(*p) );
+                            p->GrantedAccess = reply->access;
+                            p->PointerCount = reply->ref_count;
+                            p->HandleCount = 1; /* at least one */
+                            if (used_len) *used_len = sizeof(*p);
+                        }
+                    }
+                    SERVER_END_REQ;
+                }
+                break;
+            case ObjectDataInformation:
+                {
+                    OBJECT_DATA_INFORMATION* p = (OBJECT_DATA_INFORMATION*)ptr;
+
+                    if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
+
+                    SERVER_START_REQ( set_handle_info )
+                    {
+                        req->handle = handle;
+                        req->flags  = 0;
+                        req->mask   = 0;
+                        status = wine_server_call( req );
+                        if (status == STATUS_SUCCESS)
+                        {
+                            p->InheritHandle = (reply->old_flags & HANDLE_FLAG_INHERIT) ? TRUE : FALSE;
+                            p->ProtectFromClose = (reply->old_flags & HANDLE_FLAG_PROTECT_FROM_CLOSE) ? TRUE : FALSE;
+                            if (used_len) *used_len = sizeof(*p);
+                        }
+                    }
+                    SERVER_END_REQ;
+                }
+                break;
+            default:
+                FIXME("Unsupported information class %u\n", info_class);
+                status = STATUS_NOT_IMPLEMENTED;
+                break;
+        }
+    }
+    else
+    {
+        __asm__ __volatile__ (
+                "movl $0x86,%%eax\n\t"
+                "lea 8(%%ebp),%%edx\n\t"
+                "int $0x2E\n\t"
+                :"=a" (status)
+                );
+    }
+#endif
     return status;
 }
 
@@ -129,6 +200,7 @@
     TRACE("(%p,0x%08x,%p,0x%08x): stub\n",
           handle, info_class, ptr, len);
 
+#ifndef UNIFIED_KERNEL
     switch (info_class)
     {
     case ObjectDataInformation:
@@ -154,6 +226,45 @@
         status = STATUS_NOT_IMPLEMENTED;
         break;
     }
+#else
+    if (!IS_UK_HANDLE(handle))
+    {
+        switch (info_class)
+        {
+        case ObjectDataInformation:
+            {
+                OBJECT_DATA_INFORMATION* p = (OBJECT_DATA_INFORMATION*)ptr;
+
+                if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
+
+                SERVER_START_REQ( set_handle_info )
+                {
+                    req->handle = handle;
+                    req->flags  = 0;
+                    req->mask   = HANDLE_FLAG_INHERIT | HANDLE_FLAG_PROTECT_FROM_CLOSE;
+                    if (p->InheritHandle)    req->flags |= HANDLE_FLAG_INHERIT;
+                    if (p->ProtectFromClose) req->flags |= HANDLE_FLAG_PROTECT_FROM_CLOSE;
+                    status = wine_server_call( req );
+                }
+                SERVER_END_REQ;
+            }
+            break;
+        default:
+            FIXME("Unsupported information class %u\n", info_class);
+            status = STATUS_NOT_IMPLEMENTED;
+            break;
+        }
+    }
+    else
+    {
+        __asm__ __volatile__ (
+                "movl $0xB9,%%eax\n\t"
+                "lea 8(%%ebp),%%edx\n\t"
+                "int $0x2E\n\t"
+                :"=a" (status)
+                );
+    }
+#endif
     return status;
 }
 
@@ -252,6 +363,7 @@
                                    ACCESS_MASK access, ULONG attributes, ULONG options )
 {
     NTSTATUS ret;
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( dup_handle )
     {
         req->src_process = source_process;
@@ -277,6 +389,45 @@
         }
     }
     SERVER_END_REQ;
+#else
+    if (!IS_UK_HANDLE(source)) 
+    {
+        SERVER_START_REQ( dup_handle )
+        {
+            req->src_process = source_process;
+            req->src_handle  = source;
+            req->dst_process = dest_process;
+            req->access      = access;
+            req->attributes  = attributes;
+            req->options     = options;
+
+            if (!(ret = wine_server_call( req )))
+            {
+                if (dest) *dest = reply->handle;
+                if (reply->closed)
+                {
+                    if (reply->self)
+                    {
+                        int fd = server_remove_fd_from_cache( source );
+                        if (fd != -1) close( fd );
+                    }
+                }
+                else if (options & DUPLICATE_CLOSE_SOURCE)
+                    WARN( "failed to close handle %p in process %p\n", source, source_process );
+            }
+        }
+        SERVER_END_REQ;
+    }
+    else 
+    {
+        __asm__ __volatile__ (
+                "movl $0x34,%%eax\n\t"
+                "lea 8(%%ebp),%%edx\n\t"
+                "int $0x2E\n\t"
+                :"=a" (ret)
+                );
+    }
+#endif
     return ret;
 }
 
@@ -297,6 +448,7 @@
     NTSTATUS ret;
     int fd = server_remove_fd_from_cache( Handle );
 
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( close_handle )
     {
         req->handle = Handle;
@@ -304,6 +456,45 @@
     }
     SERVER_END_REQ;
     if (fd != -1) close( fd );
+#else
+    if (!IS_UK_HANDLE(Handle))
+    {
+        /* wine handle */
+        SERVER_START_REQ( close_handle )
+        {
+            req->handle = Handle;
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        if (fd != -1) close( fd );
+    }
+    else
+    {
+        __asm__ __volatile__ (
+                "movl $0x11,%%eax\n\t"
+                "lea 8(%%ebp),%%edx\n\t"
+                "int $0x2E\n\t"
+                :"=a" (ret)
+                );
+        if (!ret)
+        {
+            struct handle_pair* pair;
+
+            if ((pair = search_handle_pair(Handle)))
+            {
+                fd = server_remove_fd_from_cache( pair->wine_handle );	/* FIXME */
+                SERVER_START_REQ( close_handle )
+                {
+                    req->handle = pair->wine_handle;
+                    ret = wine_server_call( req );
+                }
+                SERVER_END_REQ;
+                if (fd != -1) close( fd );
+                delete_handle_pair(pair);
+            }
+        }
+    }
+#endif
     return ret;
 }
 
@@ -424,6 +615,7 @@
 {
     NTSTATUS ret;
 
+#ifndef UNIFIED_KERNEL
     if (restart) *context = 0;
 
     if (single_entry)
@@ -460,6 +652,52 @@
         FIXME("multiple entries not implemented\n");
         ret = STATUS_NOT_IMPLEMENTED;
     }
+#else
+    if (!IS_UK_HANDLE(handle))
+    {
+        if (restart) *context = 0;
+
+        if (single_entry) {
+            if (size <= sizeof(*buffer) + 2*sizeof(WCHAR)) return STATUS_BUFFER_OVERFLOW;
+
+            SERVER_START_REQ( get_directory_entry )
+            {
+                req->handle = handle;
+                req->index = *context;
+                wine_server_set_reply( req, buffer + 1, size - sizeof(*buffer) - 2*sizeof(WCHAR) );
+                if (!(ret = wine_server_call( req )))
+                {
+                    buffer->ObjectName.Buffer = (WCHAR *)(buffer + 1);
+                    buffer->ObjectName.Length = reply->name_len;
+                    buffer->ObjectName.MaximumLength = reply->name_len + sizeof(WCHAR);
+                    buffer->ObjectTypeName.Buffer = (WCHAR *)(buffer + 1) + reply->name_len/sizeof(WCHAR) + 1;
+                    buffer->ObjectTypeName.Length = wine_server_reply_size( reply ) - reply->name_len;
+                    buffer->ObjectTypeName.MaximumLength = buffer->ObjectTypeName.Length + sizeof(WCHAR);
+                    /* make room for the terminating null */
+                    memmove( buffer->ObjectTypeName.Buffer, buffer->ObjectTypeName.Buffer - 1,
+                            buffer->ObjectTypeName.Length );
+                    buffer->ObjectName.Buffer[buffer->ObjectName.Length/sizeof(WCHAR)] = 0;
+                    buffer->ObjectTypeName.Buffer[buffer->ObjectTypeName.Length/sizeof(WCHAR)] = 0;
+                    (*context)++;
+                }
+            }
+            SERVER_END_REQ;
+            if (ret_size)
+                *ret_size = buffer->ObjectName.MaximumLength + buffer->ObjectTypeName.MaximumLength + sizeof(*buffer);
+        } else {
+            FIXME("multiple entries not implemented\n");
+            ret = STATUS_NOT_IMPLEMENTED;
+        }
+    } else {
+        __asm__ __volatile__ (
+                "movl $0x76,%%eax\n\t"
+                "lea 8(%%ebp),%%edx\n\t"
+                "int $0x2E\n\t"
+                :"=a" (ret)
+                );
+
+    }
+#endif
 
     return ret;
 }
@@ -587,6 +825,7 @@
     NTSTATUS ret;
     TRACE("(%p,%p,%p)\n", LinkHandle, LinkTarget, ReturnedLength);
 
+#ifndef UNIFIED_KERNEL
     if (!LinkTarget) return STATUS_ACCESS_VIOLATION;
 
     SERVER_START_REQ(query_symlink)
@@ -600,6 +839,33 @@
         }
     }
     SERVER_END_REQ;
+#else
+    if (!IS_UK_HANDLE(LinkHandle))
+    {
+        if (!LinkTarget) return STATUS_ACCESS_VIOLATION;
+
+        SERVER_START_REQ(query_symlink)
+        {
+            req->handle = LinkHandle;
+            wine_server_set_reply( req, LinkTarget->Buffer, LinkTarget->MaximumLength );
+            if (!(ret = wine_server_call( req )))
+            {
+                LinkTarget->Length = wine_server_reply_size(reply);
+                if (ReturnedLength) *ReturnedLength = LinkTarget->Length;
+            }
+        }
+        SERVER_END_REQ;
+    }
+    else
+    {
+        __asm__ __volatile__ (
+                "movl $0x8C,%%eax\n\t"
+                "lea 8(%%ebp),%%edx\n\t"
+                "int $0x2E\n\t"
+                :"=a" (ret)
+                );
+    }
+#endif
     return ret;
 }
 
diff -urN wine-1.0/dlls/ntdll/path.c wine-1.0-uk/dlls/ntdll/path.c
--- wine-1.0/dlls/ntdll/path.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/path.c	2009-08-19 10:13:55.000000000 +0800
@@ -1005,6 +1005,21 @@
     size -= 4;
     if (size && ptr[size - 1] != '\\') ptr[size++] = '\\';
 
+#ifdef UNIFIED_KERNEL
+    if (curdir->DosPath.MaximumLength < (unsigned long)((size + 1) * sizeof(WCHAR))) {
+        /* allocate new memory */
+        if (curdir->DosPath.Buffer)
+            RtlFreeHeap(GetProcessHeap(), 0, curdir->DosPath.Buffer);
+        curdir->DosPath.MaximumLength = (size + 1) * sizeof(WCHAR);
+        curdir->DosPath.Buffer = RtlAllocateHeap(GetProcessHeap(),
+                0, curdir->DosPath.MaximumLength);
+        if (!curdir->DosPath.Buffer)
+        {
+            nts = !nts;
+            goto out;
+        }
+    }
+#endif
     memcpy( curdir->DosPath.Buffer, ptr, size * sizeof(WCHAR));
     curdir->DosPath.Buffer[size] = 0;
     curdir->DosPath.Length = size * sizeof(WCHAR);
diff -urN wine-1.0/dlls/ntdll/process.c wine-1.0-uk/dlls/ntdll/process.c
--- wine-1.0/dlls/ntdll/process.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/process.c	2009-08-19 10:23:24.000000000 +0800
@@ -34,12 +34,42 @@
 #include "winternl.h"
 #include "ntdll_misc.h"
 #include "wine/server.h"
+#ifdef UNIFIED_KERNEL
+#include "handle.h"
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
 /*
  *	Process object
  */
+#ifdef UNIFIED_KERNEL
+
+NTSTATUS WINAPI
+NtCreateProcess(OUT PHANDLE ProcessHandle,
+                IN ACCESS_MASK DesiredAccess,
+                IN POBJECT_ATTRIBUTES ObjectAttributes  OPTIONAL,
+                IN HANDLE ParentProcess,
+                IN BOOLEAN InheritObjectTable,
+                IN HANDLE SectionHandle  OPTIONAL,
+                IN HANDLE DebugPort  OPTIONAL,
+                IN HANDLE ExceptionPort  OPTIONAL)
+{
+	NTSTATUS ret;
+	TRACE("DesiredAccess %x, ObjectAttributes %p, name %s, ParentProcess %p, \
+		InheritObjectTable %d, SectionHandle %p, DebugPort %p, ExceptionPort %p\n",
+		DesiredAccess, ObjectAttributes, ObjectAttributes->ObjectName ? 
+		debugstr_us(ObjectAttributes->ObjectName) : NULL,
+		ParentProcess, InheritObjectTable, SectionHandle, DebugPort, ExceptionPort);
+	__asm__ __volatile__ (
+			"movl $0x22,%%eax\n\t"
+			"lea 8(%%ebp),%%edx\n\t"
+			"int $0x2E\n\t"
+			:"=a" (ret)
+			);
+	return ret;
+}
+#endif
 
 /******************************************************************************
  *  NtTerminateProcess			[NTDLL.@]
@@ -49,6 +79,7 @@
 NTSTATUS WINAPI NtTerminateProcess( HANDLE handle, LONG exit_code )
 {
     NTSTATUS ret;
+#ifndef UNIFIED_KERNEL
     BOOL self;
     SERVER_START_REQ( terminate_process )
     {
@@ -59,6 +90,33 @@
     }
     SERVER_END_REQ;
     if (self) exit( exit_code );
+#else
+    BOOL self;
+    HANDLE wine_handle;
+    
+    if (GetCurrentProcess() != handle) {
+	    struct handle_pair * pair = search_handle_pair(handle);
+	    wine_handle = pair->wine_handle;
+    } else 
+	    wine_handle = handle;
+    
+    SERVER_START_REQ( terminate_process )
+    {
+	    req->handle    = wine_handle;
+	    req->exit_code = exit_code;
+	    ret = wine_server_call( req );
+	    self = !ret && reply->self;
+    }
+    SERVER_END_REQ;
+
+    /* no return, if handle == 0xffffffff */
+    __asm__ __volatile__ (
+		    "movl $0xD3,%%eax\n\t"
+		    "lea 8(%%ebp),%%edx\n\t"
+		    "int $0x2E\n\t"
+		    :"=a" (ret)
+		    );
+#endif
     return ret;
 }
 
@@ -108,6 +166,7 @@
 	OUT PULONG ReturnLength)
 {
     NTSTATUS ret = STATUS_SUCCESS;
+#ifndef UNIFIED_KERNEL
     ULONG len = 0;
 
     TRACE("(%p,0x%08x,%p,0x%08x,%p)\n",
@@ -340,6 +399,14 @@
     }
 
     if (ReturnLength) *ReturnLength = len;
+#else
+    __asm__ __volatile__ (
+            "movl $0x7D,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+#endif
     
     return ret;
 }
@@ -356,6 +423,7 @@
 {
     NTSTATUS ret = STATUS_SUCCESS;
 
+#ifndef UNIFIED_KERNEL
     switch (ProcessInformationClass)
     {
     case ProcessAffinityMask:
@@ -396,6 +464,14 @@
         ret = STATUS_NOT_IMPLEMENTED;
         break;
     }
+#else
+    __asm__ __volatile__ (
+            "movl $0xBA,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+#endif
     return ret;
 }
 
@@ -425,6 +501,7 @@
 {
     NTSTATUS    status;
 
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( open_process )
     {
         req->pid        = HandleToULong(cid->UniqueProcess);
@@ -434,5 +511,34 @@
         if (!status) *handle = reply->handle;
     }
     SERVER_END_REQ;
+#else
+    PHANDLE uk_handle = handle;
+    HANDLE wine_handle;
+
+    __asm__ __volatile__ (
+            "movl $0x5E,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );	
+
+    if (!status)
+    {
+        SERVER_START_REQ( open_process )
+        {
+            req->pid        = (process_id_t)cid->UniqueProcess;
+            req->access     = access;
+            req->attributes = attr ? attr->Attributes : 0;
+            status = wine_server_call( req );
+            if (!status) 
+            {
+                wine_handle = reply->handle;
+                if (!store_handle_pair(*uk_handle, wine_handle))
+                    return STATUS_NO_MEMORY;
+            }
+        }
+        SERVER_END_REQ;
+    }
+#endif
     return status;
 }
diff -urN wine-1.0/dlls/ntdll/reg.c wine-1.0-uk/dlls/ntdll/reg.c
--- wine-1.0/dlls/ntdll/reg.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/reg.c	2009-08-19 10:41:18.000000000 +0800
@@ -45,6 +45,11 @@
 /* maximum length of a key/value name in bytes (without terminating null) */
 #define MAX_NAME_LENGTH ((MAX_PATH-1) * sizeof(WCHAR))
 
+#ifdef UNIFIED_KERNEL
+extern NTSTATUS WINAPI
+NtWineService(struct __server_request_info * ReqMsg);
+#endif
+
 /******************************************************************************
  * NtCreateKey [NTDLL.@]
  * ZwCreateKey [NTDLL.@]
@@ -72,7 +77,11 @@
         req->namelen    = attr->ObjectName->Length;
         wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
         if (class) wine_server_add_data( req, class->Buffer, class->Length );
+#ifndef UNIFIED_KERNEL
         if (!(ret = wine_server_call( req )))
+#else
+        if (!(ret = NtWineService(&__req)))
+#endif
         {
             *retkey = reply->hkey;
             if (dispos) *dispos = reply->created ? REG_CREATED_NEW_KEY : REG_OPENED_EXISTING_KEY;
@@ -129,7 +138,11 @@
         req->access     = access;
         req->attributes = attr->Attributes;
         wine_server_add_data( req, attr->ObjectName->Buffer, len );
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService( req );
+#endif
         *retkey = reply->hkey;
     }
     SERVER_END_REQ;
@@ -162,7 +175,11 @@
     SERVER_START_REQ( delete_key )
     {
         req->hkey = hkey;
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService( req );
+#endif
     }
     SERVER_END_REQ;
     return ret;
@@ -193,7 +210,11 @@
     {
         req->hkey = hkey;
         wine_server_add_data( req, name->Buffer, name->Length );
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService( req );
+#endif
     }
     SERVER_END_REQ;
     return ret;
@@ -230,7 +251,11 @@
         req->index      = index;
         req->info_class = info_class;
         if (length > fixed_size) wine_server_set_reply( req, data_ptr, length - fixed_size );
+#ifndef UNIFIED_KERNEL
         if (!(ret = wine_server_call( req )))
+#else
+        if (!(ret = NtWineService( req )))
+#endif
         {
             LARGE_INTEGER modif;
 
@@ -445,7 +470,11 @@
         req->index      = index;
         req->info_class = info_class;
         if (length > fixed_size) wine_server_set_reply( req, ptr, length - fixed_size );
+#ifndef UNIFIED_KERNEL
         if (!(ret = wine_server_call( req )))
+#else
+        if (!(ret = NtWineService( req )))
+#endif
         {
             copy_key_value_info( info_class, info, length, reply->type, reply->namelen,
                                  wine_server_reply_size(reply) - reply->namelen );
@@ -518,7 +547,11 @@
         req->hkey = handle;
         wine_server_add_data( req, name->Buffer, name->Length );
         if (length > fixed_size && data_ptr) wine_server_set_reply( req, data_ptr, length - fixed_size );
+#ifndef UNIFIED_KERNEL
         if (!(ret = wine_server_call( req )))
+#else
+        if (!(ret = NtWineService( req )))
+#endif
         {
             copy_key_value_info( info_class, info, length, reply->type,
                                  name->Length, reply->total );
@@ -579,7 +612,11 @@
     SERVER_START_REQ( flush_key )
     {
 	req->hkey = key;
+#ifndef UNIFIED_KERNEL
 	ret = wine_server_call( req );
+#else
+        ret = NtWineService( req );
+#endif
     }
     SERVER_END_REQ;
     
@@ -607,7 +644,11 @@
         req->hkey = attr->RootDirectory;
         req->file = hive;
         wine_server_add_data(req, attr->ObjectName->Buffer, attr->ObjectName->Length);
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService( req );
+#endif
     }
     SERVER_END_REQ;
 
@@ -656,7 +697,11 @@
         req->event   = Event;
         req->subtree = WatchSubtree;
         req->filter  = CompletionFilter;
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService( req );
+#endif
     }
     SERVER_END_REQ;
  
@@ -730,7 +775,11 @@
     {
         req->hkey = KeyHandle;
         req->file = FileHandle;
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService( req );
+#endif
     }
     SERVER_END_REQ;
 
@@ -776,7 +825,11 @@
         req->namelen = name->Length;
         wine_server_add_data( req, name->Buffer, name->Length );
         wine_server_add_data( req, data, count );
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService( req );
+#endif
     }
     SERVER_END_REQ;
     return ret;
@@ -808,7 +861,11 @@
     SERVER_START_REQ( unload_registry )
     {
         req->hkey = attr->RootDirectory;
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call(req);
+#else
+        ret = NtWineService( req );
+#endif
     }
     SERVER_END_REQ;
 
diff -urN wine-1.0/dlls/ntdll/server.c wine-1.0-uk/dlls/ntdll/server.c
--- wine-1.0/dlls/ntdll/server.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/server.c	2009-08-19 10:22:48.000000000 +0800
@@ -60,6 +60,8 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
+#include "handle.h"
+
 
 WINE_DEFAULT_DEBUG_CHANNEL(server);
 
@@ -108,6 +110,23 @@
 static void server_connect_error( const char *serverdir ) __attribute__((noreturn));
 #endif
 
+#ifdef UNIFIED_KERNEL
+NTSTATUS WINAPI
+NtWineService(struct __server_request_info * ReqMsg)
+{
+    NTSTATUS ret;
+
+    __asm__ __volatile__ (
+            "movl $0xe8,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+
+    return ret;
+}
+
+#endif
 /* die on a fatal error; use only during initialization */
 static void fatal_error( const char *err, ... )
 {
@@ -139,6 +158,7 @@
  */
 void server_exit_thread( int status )
 {
+#ifndef UNIFIED_KERNEL
     struct wine_pthread_thread_info info;
     SIZE_T size;
     int fds[4];
@@ -173,20 +193,57 @@
     close( fds[2] );
     close( fds[3] );
     pthread_functions.exit_thread( &info );
+#else
+    int fds[4];
+
+    RtlAcquirePebLock();
+    RemoveEntryList( &NtCurrentTeb()->TlsLinks );
+    RtlReleasePebLock();
+
+    RtlFreeHeap( GetProcessHeap(), 0, NtCurrentTeb()->FlsSlots ); /* HCZ */
+    RtlFreeHeap( GetProcessHeap(), 0, NtCurrentTeb()->TlsExpansionSlots ); /* HCZ */
+
+    fds[0] = ntdll_get_thread_data()->wait_fd[0];
+    fds[1] = ntdll_get_thread_data()->wait_fd[1];
+    fds[2] = ntdll_get_thread_data()->reply_fd;
+    fds[3] = ntdll_get_thread_data()->request_fd;
+
+    close( fds[0] );
+    close( fds[1] );
+    close( fds[2] );
+    close( fds[3] );
+
+    sigprocmask( SIG_BLOCK, &server_block_set, NULL );
+
+    NtTerminateThread(GetCurrentThread(),0);
+#endif
 }
 
 
 /***********************************************************************
  *           server_abort_thread
  */
+#ifndef UNIFIED_KERNEL
 void server_abort_thread( int status )
+#else
+int server_abort_thread( int status )
+#endif
 {
+#ifndef UNIFIED_KERNEL
     pthread_functions.sigprocmask( SIG_BLOCK, &server_block_set, NULL );
+#else
+    sigprocmask( SIG_BLOCK, &server_block_set, NULL );
+#endif
     close( ntdll_get_thread_data()->wait_fd[0] );
     close( ntdll_get_thread_data()->wait_fd[1] );
     close( ntdll_get_thread_data()->reply_fd );
     close( ntdll_get_thread_data()->request_fd );
+#ifndef UNIFIED_KERNEL   
     pthread_functions.abort_thread( status );
+#else
+
+    return NtTerminateThread(GetCurrentThread(), status);
+#endif
 }
 
 
@@ -323,10 +380,18 @@
     sigset_t old_set;
     unsigned int ret;
 
+#ifndef UNIFIED_KERNEL
     pthread_functions.sigprocmask( SIG_BLOCK, &server_block_set, &old_set );
+#else
+    sigprocmask( SIG_BLOCK, &server_block_set, &old_set );
+#endif
     ret = send_request( req );
     if (!ret) ret = wait_reply( req );
+#ifndef UNIFIED_KERNEL
     pthread_functions.sigprocmask( SIG_SETMASK, &old_set, NULL );
+#else
+    sigprocmask( SIG_SETMASK, &old_set, NULL );
+#endif
     return ret;
 }
 
@@ -336,7 +401,11 @@
  */
 void server_enter_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset )
 {
+#ifndef UNIFIED_KERNEL
     pthread_functions.sigprocmask( SIG_BLOCK, &server_block_set, sigset );
+#else
+    sigprocmask( SIG_BLOCK, &server_block_set, sigset );
+#endif
     RtlEnterCriticalSection( cs );
 }
 
@@ -347,7 +416,11 @@
 void server_leave_uninterrupted_section( RTL_CRITICAL_SECTION *cs, sigset_t *sigset )
 {
     RtlLeaveCriticalSection( cs );
+#ifndef UNIFIED_KERNEL
     pthread_functions.sigprocmask( SIG_SETMASK, sigset, NULL );
+#else
+    sigprocmask( SIG_SETMASK, sigset, NULL );
+#endif
 }
 
 
@@ -459,7 +532,11 @@
         server_protocol_perror("recvmsg");
     }
     /* the server closed the connection; time to die... */
+#ifndef UNIFIED_KERNEL
     server_abort_thread(0);
+#else
+    return server_abort_thread(0);
+#endif
 }
 
 
@@ -475,16 +552,35 @@
 };
 
 #define FD_CACHE_BLOCK_SIZE  (65536 / sizeof(struct fd_cache_entry))
+#ifdef UNIFIED_KERNEL
+#define FD_CACHE_ENTRIES     256
+#else
 #define FD_CACHE_ENTRIES     128
+#endif
 
 static struct fd_cache_entry *fd_cache[FD_CACHE_ENTRIES];
 static struct fd_cache_entry fd_cache_initial_block[FD_CACHE_BLOCK_SIZE];
 
 static inline unsigned int handle_to_index( obj_handle_t handle, unsigned int *entry )
 {
+#ifdef UNIFIED_KERNEL
+    unsigned long idx;
+
+    if (IS_UK_HANDLE(handle))
+        idx = (((unsigned long)UK_HANDLE_TO_HANDLE(handle)) >> 2) - 1;
+    else
+        idx = ((unsigned long)handle >> 2) - 1;
+    *entry = idx / FD_CACHE_BLOCK_SIZE;
+    if (*entry > FD_CACHE_ENTRIES / 2)
+        *entry = FD_CACHE_ENTRIES;
+    if (IS_UK_HANDLE(handle))
+        *entry += FD_CACHE_ENTRIES / 2;
+    return idx % FD_CACHE_BLOCK_SIZE;
+#else
     unsigned long idx = ((unsigned long)handle >> 2) - 1;
     *entry = idx / FD_CACHE_BLOCK_SIZE;
     return idx % FD_CACHE_BLOCK_SIZE;
+#endif
 }
 
 
@@ -585,6 +681,7 @@
     fd = get_cached_fd( handle, type, &access, options );
     if (fd != -1) goto done;
 
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( get_handle_fd )
     {
         req->handle = handle;
@@ -604,6 +701,42 @@
         }
     }
     SERVER_END_REQ;
+#else
+    SERVER_START_REQ( get_handle_fd )
+    {
+        req->handle = handle;
+        if (!IS_UK_HANDLE(handle))
+            ret = wine_server_call( req );
+        else
+            ret = NtWineService( req );
+
+        if (!ret)
+        {
+            if (type) *type = reply->type;
+            if (options) *options = reply->options;
+            access = reply->access;
+            if (!IS_UK_HANDLE(handle))
+                fd = receive_fd( &fd_handle );
+            else
+                fd = reply->fd;
+
+            if (fd != -1)
+            {
+                if (!IS_UK_HANDLE(handle)) {
+                    assert( fd_handle == handle );
+                    *needs_close = (reply->removable ||
+                            !add_fd_to_cache( handle, fd, reply->type,
+                                reply->access, reply->options ));
+                } else {
+                    *needs_close = FALSE;
+                    add_fd_to_cache( handle, fd, reply->type, reply->access, reply->options);
+                }
+            }
+            else ret = STATUS_TOO_MANY_OPENED_FILES;
+        }
+    }
+    SERVER_END_REQ;
+#endif
 
 done:
     server_leave_uninterrupted_section( &fd_cache_section, &sigset );
@@ -959,7 +1092,11 @@
     sigaddset( &server_block_set, SIGUSR1 );
     sigaddset( &server_block_set, SIGUSR2 );
     sigaddset( &server_block_set, SIGCHLD );
+#ifndef UNIFIED_KERNEL
     pthread_functions.sigprocmask( SIG_BLOCK, &server_block_set, NULL );
+#else
+    sigprocmask( SIG_BLOCK, &server_block_set, NULL );
+#endif
 
     /* receive the first thread request fd on the main socket */
     ntdll_get_thread_data()->request_fd = receive_fd( &dummy_handle );
@@ -1049,6 +1186,10 @@
         req->reply_fd    = reply_pipe[1];
         req->wait_fd     = ntdll_get_thread_data()->wait_fd[1];
         req->debug_level = (TRACE_ON(server) != 0);
+#ifdef UNIFIED_KERNEL
+        req->pid	 = (int) NtCurrentTeb()->RealClientId.UniqueProcess;
+        req->tid	 = (int) NtCurrentTeb()->RealClientId.UniqueThread;
+#endif
         ret = wine_server_call( req );
         NtCurrentTeb()->ClientId.UniqueProcess = ULongToHandle(reply->pid);
         NtCurrentTeb()->ClientId.UniqueThread  = ULongToHandle(reply->tid);
diff -urN wine-1.0/dlls/ntdll/sync.c wine-1.0-uk/dlls/ntdll/sync.c
--- wine-1.0/dlls/ntdll/sync.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/sync.c	2009-08-19 10:44:09.000000000 +0800
@@ -57,6 +57,9 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
+#ifdef UNIFIED_KERNEL
+#include "handle.h"
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
@@ -143,6 +146,7 @@
                                    IN LONG InitialCount,
                                    IN LONG MaximumCount )
 {
+#ifndef UNIFIED_KERNEL
     DWORD len = attr && attr->ObjectName ? attr->ObjectName->Length : 0;
     NTSTATUS ret;
     struct object_attributes objattr;
@@ -176,6 +180,16 @@
     SERVER_END_REQ;
 
     NTDLL_free_struct_sd( sd );
+#else
+    NTSTATUS ret;
+
+    __asm__ __volatile__ (
+            "movl $0x25,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+#endif
 
     return ret;
 }
@@ -187,6 +201,7 @@
                                  IN ACCESS_MASK access,
                                  IN const OBJECT_ATTRIBUTES *attr )
 {
+#ifndef UNIFIED_KERNEL
     DWORD len = attr && attr->ObjectName ? attr->ObjectName->Length : 0;
     NTSTATUS ret;
 
@@ -202,6 +217,16 @@
         *SemaphoreHandle = reply->handle;
     }
     SERVER_END_REQ;
+#else
+    NTSTATUS ret;
+
+    __asm__ __volatile__ (
+            "movl $0x62,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+#endif
     return ret;
 }
 
@@ -226,6 +251,7 @@
 NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, PULONG previous )
 {
     NTSTATUS ret;
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( release_semaphore )
     {
         req->handle = handle;
@@ -236,6 +262,14 @@
         }
     }
     SERVER_END_REQ;
+#else
+    __asm__ __volatile__ (
+            "movl $0x9E,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+#endif
     return ret;
 }
 
@@ -419,6 +453,7 @@
                                IN BOOLEAN InitialOwner)
 {
     NTSTATUS status;
+#ifndef UNIFIED_KERNEL
     DWORD len = attr && attr->ObjectName ? attr->ObjectName->Length : 0;
     struct security_descriptor *sd = NULL;
     struct object_attributes objattr;
@@ -448,6 +483,14 @@
     SERVER_END_REQ;
 
     NTDLL_free_struct_sd( sd );
+#else
+    __asm__ __volatile__ (
+            "movl $0x1E,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+#endif
 
     return status;
 }
@@ -461,6 +504,7 @@
                              IN const OBJECT_ATTRIBUTES* attr )
 {
     NTSTATUS    status;
+#ifndef UNIFIED_KERNEL
     DWORD       len = attr && attr->ObjectName ? attr->ObjectName->Length : 0;
 
     if (len >= MAX_PATH * sizeof(WCHAR)) return STATUS_NAME_TOO_LONG;
@@ -475,6 +519,14 @@
         *MutantHandle = reply->handle;
     }
     SERVER_END_REQ;
+#else
+    __asm__ __volatile__ (
+            "movl $0x5C,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+#endif
     return status;
 }
 
@@ -486,6 +538,7 @@
 {
     NTSTATUS    status;
 
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( release_mutex )
     {
         req->handle = handle;
@@ -493,6 +546,14 @@
         if (prev_count) *prev_count = reply->prev_count;
     }
     SERVER_END_REQ;
+#else
+    __asm__ __volatile__ (
+            "movl $0x9D,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+#endif
     return status;
 }
 
@@ -755,7 +816,11 @@
         server_protocol_perror("wakeup read");
     }
     /* the server closed the connection; time to die... */
+#ifndef UNIFIED_KERNEL
     server_abort_thread(0);
+#else
+    return server_abort_thread(0);
+#endif
 }
 
 
@@ -1016,6 +1081,7 @@
                                           BOOLEAN wait_all, BOOLEAN alertable,
                                           const LARGE_INTEGER *timeout )
 {
+#ifndef UNIFIED_KERNEL
     UINT flags = SELECT_INTERRUPTIBLE;
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
@@ -1023,6 +1089,32 @@
     if (wait_all) flags |= SELECT_ALL;
     if (alertable) flags |= SELECT_ALERTABLE;
     return NTDLL_wait_for_multiple_objects( count, handles, flags, timeout, 0 );
+#else
+    NTSTATUS ret = WAIT_TIMEOUT;
+    UINT flags = SELECT_INTERRUPTIBLE;
+
+    if (!count || count > MAXIMUM_WAIT_OBJECTS)
+        return STATUS_INVALID_PARAMETER_1;
+
+    if (wait_all) flags |= SELECT_ALL;
+    if (alertable) flags |= SELECT_ALERTABLE;
+
+    if (!IS_UK_HANDLE(*handles)) {
+        ret = NTDLL_wait_for_multiple_objects( count, handles, flags, timeout, 0);
+    }
+    else {
+        do{
+            __asm__ __volatile__ (
+                    "movl $0xDE,%%eax\n\t"
+                    "lea 8(%%ebp),%%edx\n\t"
+                    "int $0x2E\n\t"
+                    :"=a" (ret)
+                    );
+        } while (-EINTR == ret);
+    }
+
+    return ret;
+#endif
 }
 
 
diff -urN wine-1.0/dlls/ntdll/thread.c wine-1.0-uk/dlls/ntdll/thread.c
--- wine-1.0/dlls/ntdll/thread.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/thread.c	2009-08-19 10:23:18.000000000 +0800
@@ -42,6 +42,193 @@
 #include "ntdll_misc.h"
 #include "ddk/wdm.h"
 #include "wine/exception.h"
+#ifdef UNIFIED_KERNEL
+#include <assert.h>
+#include "handle.h"
+#include <stdio.h>
+#include <elf.h>
+#include <link.h>
+
+#include <unistd.h>
+
+#define	PTHREAD_KEYS_MAX		1024
+#define PTHREAD_KEY_2NDLEVEL_SIZE       32
+#define PTHREAD_KEY_1STLEVEL_SIZE \
+	((PTHREAD_KEYS_MAX + PTHREAD_KEY_2NDLEVEL_SIZE - 1) \
+	 / PTHREAD_KEY_2NDLEVEL_SIZE)
+
+typedef unsigned char	bool;
+
+typedef struct
+{
+	void *tcb;        /* Pointer to the TCB.  Not necessarily the
+			     thread descriptor used by libpthread.  */
+	/* dtv_t *dtv; */
+	void *dtv;
+	void *self;       /* Pointer to the thread descriptor.  */
+	int multiple_threads;
+	uintptr_t sysinfo;
+	uintptr_t stack_guard;
+	uintptr_t pointer_guard;
+} tcbhead_t;
+
+typedef struct list_head
+{
+	struct list_head *next;
+	struct list_head *prev;
+} list_t;
+
+typedef int lll_lock_t;
+typedef unsigned long long int hp_timing_t;
+
+struct robust_list_head
+{
+	void *list;
+	long int futex_offset;
+	void *list_op_pending;
+};
+
+/* Thread descriptor data structure.  */
+struct pthread
+{
+	union
+	{
+		/* This overlaps the TCB as used for TLS without threads (see tls.h).  */
+		tcbhead_t header;
+		/* This extra padding has no special purpose, and this structure layout
+		   is private and subject to change without affecting the official ABI.
+		   We just have it here in case it might be convenient for some
+		   implementation-specific instrumentation hack or suchlike.  */
+		void *__padding[16];
+	};
+
+	/* This descriptor's link on the `stack_used' or `__stack_user' list.  */
+	list_t list;
+
+	/* Thread ID - which is also a 'is this thread descriptor (and
+	   therefore stack) used' flag.  */
+	pid_t tid;
+
+	/* Process ID - thread group ID in kernel speak.  */
+	pid_t pid;
+
+	/* List of robust mutexes the thread is holding.  */
+/*	union
+	{
+		__pthread_slist_t robust_list; */
+	struct robust_list_head robust_head;
+/*	}; */
+
+	/* List of cleanup buffers.  */
+	/* struct _pthread_cleanup_buffer *cleanup; */
+	void	*cleanup;
+
+	/* Unwind information.  */
+	/* struct pthread_unwind_buf *cleanup_jmp_buf; */
+	void	*cleanup_jmp_buf;
+
+	/* Flags determining processing of cancellation.  */
+	int cancelhandling;
+
+	/* Flags.  Including those copied from the thread attribute.  */
+	int flags;
+
+	/* We allocate one block of references here.  This should be enough
+	   to avoid allocating any memory dynamically for most applications.  */
+	struct pthread_key_data
+	{
+		/* Sequence number.  We use uintptr_t to not require padding on
+		   32- and 64-bit machines.  On 64-bit machines it helps to avoid
+		   wrapping, too.  */
+		uintptr_t seq;
+
+		/* Data pointer.  */
+		void *data;
+	} specific_1stblock[PTHREAD_KEY_2NDLEVEL_SIZE];
+
+	/* Two-level array for the thread-specific data.  */
+	struct pthread_key_data *specific[PTHREAD_KEY_1STLEVEL_SIZE];
+
+	/* Flag which is set when specific data is set.  */
+	bool specific_used;
+
+	/* True if events must be reported.  */
+	bool report_events;
+
+	/* True if the user provided the stack.  */
+	bool user_stack;
+
+	/* True if thread must stop at startup time.  */
+	bool stopped_start;
+
+	/* The parent's cancel handling at the time of the pthread_create
+	   call.  This might be needed to undo the effects of a cancellation.  */
+	int parent_cancelhandling;
+
+	/* Lock to synchronize access to the descriptor.  */
+	lll_lock_t lock;
+
+	/* Lock for synchronizing setxid calls.  */
+	lll_lock_t setxid_futex;
+
+	/* Offset of the CPU clock at start thread start time.  */
+	hp_timing_t cpuclock_offset;
+
+	/* If the thread waits to join another one the ID of the latter is
+	   stored here.
+
+	   In case a thread is detached this field contains a pointer of the
+	   TCB if the thread itself.  This is something which cannot happen
+	   in normal operation.  */
+	struct pthread *joinid;
+
+	/* The result of the thread function.  */
+	void *result;
+
+	/* Scheduling parameters for the new thread.  */
+	struct sched_param schedparam;
+	int schedpolicy;
+
+	/* Start position of the code to be executed and the argument passed
+	   to the function.  */
+	void *(*start_routine) (void *);
+	void *arg;
+
+	/* Debug state.  */
+	/* td_eventbuf_t eventbuf; */
+	char	eventbuf[16];
+
+	/* Next descriptor with a pending event.  */
+	struct pthread *nextevent;
+
+	/* Machine-specific unwind info.  */
+	/* struct _Unwind_Exception exc; */
+	char	exc[32];
+
+	/* If nonzero pointer to area allocated for the stack and its
+	   size.  */
+	void *stackblock;
+	size_t stackblock_size;
+	/* Size of the included guard area.  */
+	size_t guardsize;
+	/* This is what the user specified and what we will report.  */
+	size_t reported_guardsize;
+
+	/* Thread Priority Protection data.  */
+	/* struct priority_protection_data *tpp; */
+	void	*tpp;
+
+	/* Resolver state.  */
+	/* struct __res_state res; */
+	char	res[0x200];
+} __attribute ((aligned(16)));
+
+static inline void set_pthread_tid(struct pthread *pthread, pid_t tid)
+{
+    pthread->tid = tid;
+}
+
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(thread);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
@@ -64,7 +251,25 @@
 static RTL_BITMAP tls_bitmap;
 static RTL_BITMAP tls_expansion_bitmap;
 static RTL_BITMAP fls_bitmap;
+#ifndef UNIFIED_KERNEL
 static LIST_ENTRY tls_links;
+#else
+LIST_ENTRY tls_links;
+#define ROUNDUP(a, b) ((((a) + (b) - 1)/(b))*(b))
+
+#define PAGE_SIZE 0x1000
+
+#define	DEFAULT_STACK_SIZE	0x200000
+#define	DEFAULT_GUARD_SIZE	0x1000
+#define DEFAULT_COMMIT_SIZE	(32 * PAGE_SIZE)
+
+#define USER_CS         (0x18 + 0x3)
+#define USER_DS         (0x20 + 0x3)
+#define TEB_SELECTOR    (0x38 + 0x3)
+
+extern char **environ;
+extern void ProcessStartForward(unsigned long start_address, void *peb);
+#endif
 static size_t sigstack_total_size;
 static ULONG sigstack_zero_bits;
 
@@ -160,7 +365,11 @@
  *
  * Fill the RTL_USER_PROCESS_PARAMETERS structure from the server.
  */
+#ifndef UNIFIED_KERNEL
 static NTSTATUS init_user_process_params( SIZE_T info_size, HANDLE *exe_file )
+#else
+NTSTATUS init_user_process_params( SIZE_T info_size, HANDLE *exe_file )
+#endif
 {
     void *ptr;
     SIZE_T env_size;
@@ -405,6 +614,7 @@
 }
 
 
+#ifndef UNIFIED_KERNEL
 /***********************************************************************
  *           start_thread
  *
@@ -451,6 +661,50 @@
     else
         call_thread_func( func, arg );
 }
+#else
+void start_thread(ULONG unknown1, ULONG unknown2, ULONG unknown3)
+{
+    TEB *teb = NtCurrentTeb();
+    struct ntdll_thread_data *thread_data = (struct ntdll_thread_data *)teb->SystemReserved2;
+    struct debug_info debug_info;
+    struct pthread *pthread;
+
+    asm volatile ("movl %%gs:0x8, %0" : "=r"(pthread));
+    set_pthread_tid(pthread, gettid());
+
+    thread_data->debug_info = &debug_info;
+    debug_info.str_pos = debug_info.strings;
+    debug_info.out_pos = debug_info.output;
+
+    thread_data->fs = 0;
+    asm("mov %%fs, %0\n" : "=m"(thread_data->fs));
+
+    SIGNAL_Init();
+    server_init_thread(getpid(), gettid(), NULL );
+    RtlAcquirePebLock();
+    InsertHeadList( &tls_links, &teb->TlsLinks );
+    RtlReleasePebLock();
+
+    /* NOTE: Windows does not have an exception handler around the call to
+     * the thread attach. We do for ease of debugging */
+    if (unhandled_exception_filter)
+    {
+        __TRY
+        {
+            MODULE_DllThreadAttach( NULL );
+        }
+        __EXCEPT(unhandled_exception_filter)
+        {
+            NtTerminateThread( GetCurrentThread(), GetExceptionCode() );
+        }
+        __ENDTRY
+    }
+    else
+        MODULE_DllThreadAttach( NULL );
+
+    return;
+}
+#endif
 
 
 /***********************************************************************
@@ -568,7 +822,11 @@
 
     info->pthread_info.stack_base = NULL;
     info->pthread_info.stack_size = stack_reserve;
+#ifndef UNIFIED_KERNEL
     info->pthread_info.entry      = start_thread;
+#else
+    info->pthread_info.entry      = (void *)start_thread;
+#endif
     info->entry_point             = start;
     info->entry_arg               = param;
 
@@ -598,6 +856,601 @@
     return status;
 }
 
+#ifdef UNIFIED_KERNEL
+NTSTATUS WINAPI
+NtCreateThread(OUT PHANDLE ThreadHandle,
+        IN ACCESS_MASK DesiredAccess,
+        IN POBJECT_ATTRIBUTES ObjectAttributes  OPTIONAL,
+        IN HANDLE ProcessHandle,
+        OUT PCLIENT_ID ClientId,
+        IN PCONTEXT ThreadContext,
+        IN PINITIAL_TEB InitialTeb,
+        IN BOOLEAN CreateSuspended)
+{
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0x27,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+}
+
+VOID RtlRosR32AttribsToNativeAttribs(OUT OBJECT_ATTRIBUTES * NativeAttribs,
+        IN SECURITY_ATTRIBUTES * Ros32Attribs OPTIONAL)
+{
+    NativeAttribs->Length = sizeof(*NativeAttribs);
+    NativeAttribs->ObjectName = NULL;
+    NativeAttribs->RootDirectory = NULL;
+    NativeAttribs->Attributes = 0;
+    NativeAttribs->SecurityQualityOfService = NULL;
+
+    if(Ros32Attribs && Ros32Attribs->nLength >= sizeof(*Ros32Attribs)) {
+        NativeAttribs->SecurityDescriptor = Ros32Attribs->lpSecurityDescriptor;
+
+        if(Ros32Attribs->bInheritHandle)
+            NativeAttribs->Attributes |= OBJ_INHERIT;
+    } else
+        NativeAttribs->SecurityDescriptor = NULL;
+}
+
+NTSTATUS NTAPI RtlpRosGetStackLimits(IN PINITIAL_TEB InitialTeb,
+        OUT PVOID * StackBase,
+        OUT PVOID * StackLimit)
+{
+    /* fixed-size stack */
+    if(InitialTeb->StackBase && InitialTeb->StackLimit) {
+        *StackBase = InitialTeb->StackBase;
+        *StackLimit = InitialTeb->StackLimit;
+    } else if(InitialTeb->StackCommit && InitialTeb->StackCommitMax) { /* expandable stack */
+        *StackBase = InitialTeb->StackCommit;
+        *StackLimit = InitialTeb->StackCommitMax;
+    } else { /* can't determine the type of stack: failure */
+        return STATUS_BAD_INITIAL_STACK;
+    }
+
+    /* valid stack */
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS NTAPI RtlpRosValidateLinearUserStack(IN PVOID StackBase,
+        IN PVOID StackLimit,
+        IN BOOLEAN Direction)
+{
+    /* the stack has a null or negative (relatively to its direction) length */
+    if (StackBase == StackLimit || (Direction ^ ((PCHAR)StackBase < (PCHAR)StackLimit)))
+        return STATUS_BAD_INITIAL_STACK;
+
+    /* valid stack */
+    return STATUS_SUCCESS;
+}
+
+
+NTSTATUS NTAPI
+RtlRosInitializeContext(IN HANDLE ProcessHandle,
+        OUT PCONTEXT Context,
+        IN PVOID BaseStartAddress,
+        IN PINITIAL_TEB InitialTeb,
+        IN ULONG_PTR StartAddress,
+        IN ULONG_PTR Parameter)
+{
+    static PVOID spRetAddr = (PVOID)0xDEADBEEF;
+
+    SIZE_T nDummy;
+    NTSTATUS nErrCode;
+    PVOID pStackBase;
+    PVOID pStackLimit;
+    size_t ReserveSize = 3 * sizeof(ULONG_PTR);
+
+    /* Intel x86: linear top-down stack, all parameters passed on the stack */
+    /* get the stack base and limit */
+    nErrCode = RtlpRosGetStackLimits(InitialTeb, &pStackBase, &pStackLimit);
+
+    /* failure */
+    if(nErrCode)
+        return nErrCode;
+
+    /* validate the stack */
+    nErrCode = RtlpRosValidateLinearUserStack(pStackBase, pStackLimit, FALSE);
+
+    /* failure */
+    if(nErrCode)
+        return nErrCode;
+
+    /* too many parameters */
+    if((SIZE_T)((ULONG_PTR)pStackBase - (ULONG_PTR)pStackLimit) < ReserveSize)
+        return STATUS_STACK_OVERFLOW;
+
+    memset(Context, 0, sizeof(CONTEXT));
+
+    /* initialize the context */
+    Context->ContextFlags = CONTEXT_FULL;
+
+    if(!BaseStartAddress)
+        Context->Eip = (ULONG_PTR)ProcessStartForward;
+    else
+        Context->Eip = (ULONG_PTR)BaseStartAddress;
+
+    Context->SegGs = USER_DS;
+    Context->SegFs = TEB_SELECTOR;
+    Context->SegEs = USER_DS;
+    Context->SegDs = USER_DS;
+    Context->SegCs = USER_CS;
+    Context->SegSs = USER_DS;
+    Context->Esp = (ULONG_PTR)pStackBase - ReserveSize;
+    /* FIXME: use this value for eflag temporarily */
+    Context->EFlags = ((ULONG_PTR)1 << 1) | ((ULONG_PTR)1 << 9);
+
+    /* write the parameter */
+    nErrCode = NtWriteVirtualMemory(ProcessHandle,
+            ((PUCHAR)pStackBase) - sizeof(ULONG_PTR),
+            (void *)&Parameter,
+            sizeof(Parameter),
+            &nDummy);
+
+    /* failure */
+    if(nErrCode)
+        return nErrCode;
+
+    /* write the parameter */
+    nErrCode = NtWriteVirtualMemory(ProcessHandle,
+            ((PUCHAR)pStackBase) - 2 * sizeof(ULONG_PTR),
+            (void *)&StartAddress,
+            sizeof(StartAddress),
+            &nDummy);
+
+    /* failure */
+    if(nErrCode)
+        return nErrCode;
+
+    /* write the return address */
+    return NtWriteVirtualMemory(ProcessHandle,
+            ((PUCHAR)pStackBase) - ReserveSize,
+            &spRetAddr,
+            sizeof(spRetAddr),
+            &nDummy);
+}
+
+NTSTATUS NTAPI RtlRosDeleteStack(IN HANDLE ProcessHandle,
+        IN PINITIAL_TEB InitialTeb)
+{
+    PVOID pStackLowest = NULL;
+    ULONG_PTR nSize;
+
+    if(InitialTeb->StackLimit)
+        pStackLowest = InitialTeb->StackLimit;
+    else if(InitialTeb->StackReserved)
+        pStackLowest = InitialTeb->StackReserved;
+
+    /* free the stack, if it was allocated */
+    if(pStackLowest)
+        return NtFreeVirtualMemory(ProcessHandle, &pStackLowest, &nSize, MEM_RELEASE);
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS NTAPI RtlRosCreateStack(IN HANDLE ProcessHandle,
+        OUT PINITIAL_TEB InitialTeb,
+        IN LONG StackZeroBits,
+        IN OUT PULONG StackReserve OPTIONAL,
+        IN OUT PULONG StackCommit OPTIONAL)
+{
+    NTSTATUS nErrCode;
+    ULONG_PTR StackSize = DEFAULT_STACK_SIZE;
+
+    /* FIXME: ignore the StackReserve and the StackCommit that user thread need */
+
+    /* FIXME: this code assumes a stack growing downwards */
+    /* expandable stack */
+
+    InitialTeb->StackBase = NULL;
+    InitialTeb->StackReserved = NULL;
+
+    nErrCode = NtAllocateVirtualMemory(ProcessHandle,
+            &InitialTeb->StackBase,
+            StackZeroBits,
+            (SIZE_T *)&StackSize,
+            MEM_RESERVE | MEM_COMMIT,
+            PAGE_READWRITE);
+    /* failure */
+    if (nErrCode)
+        goto l_Fail;
+
+    InitialTeb->StackLimit = InitialTeb->StackBase;
+    InitialTeb->StackBase = (PVOID)((unsigned long)InitialTeb->StackBase + StackSize);
+
+    /* success */
+    return STATUS_SUCCESS;
+
+    /* deallocate the stack */
+    RtlRosDeleteStack(ProcessHandle, InitialTeb);
+
+    /* failure */
+l_Fail:
+    assert(nErrCode);
+    return nErrCode;
+}
+
+extern ElfW(auxv_t) *auxvec;
+extern size_t auxvec_len;
+NTSTATUS NTAPI RtlRosInitializeStack(IN HANDLE ProcessHandle,
+        OUT PINITIAL_TEB InitialTeb)
+{
+    int envc = 0, argc = 0;
+    int in_app_name = 0;
+    int i = 0;
+    unsigned long size, size_out;
+    char **envp = environ, **tmp, **argv = NULL;
+    char *last_env = NULL;
+    char *child_stack_start, *child_env, *child_argv;
+    void *stack, *stack_u = NULL;
+    unsigned long env_start, env_end, delta;
+    char *c, *p = NULL, *cmd_line = NULL;
+    PVOID cmd_addr;
+    PWCHAR cmd_line_w = NULL, wc;
+    PWCHAR app_name_w = NULL;
+    PEB child_peb;
+    RTL_USER_PROCESS_PARAMETERS child_ppb;
+    NTSTATUS ret;
+
+    ret = NtReadVirtualMemory(ProcessHandle,
+            (PVOID)0x7ffdf000UL,
+            (PVOID)&child_peb,
+            sizeof(PEB),
+            &size);
+    if (ret)
+        return ret;
+
+    ret = NtReadVirtualMemory(ProcessHandle,
+            (PVOID)child_peb.ProcessParameters,
+            (PVOID)&child_ppb,
+            sizeof(RTL_USER_PROCESS_PARAMETERS),
+            &size);
+    if (ret)
+        return ret;
+
+    cmd_line_w = (PWCHAR)malloc(child_ppb.CommandLine.MaximumLength);
+    cmd_addr =(PVOID)((unsigned long)child_ppb.CommandLine.Buffer);
+    if((unsigned long)cmd_addr < (unsigned long)child_peb.ProcessParameters){
+        cmd_addr = (PVOID)((unsigned long)child_ppb.CommandLine.Buffer 
+                + (unsigned long)child_peb.ProcessParameters);
+    }
+
+    ret = NtReadVirtualMemory(ProcessHandle,
+            cmd_addr,
+            (PVOID)cmd_line_w,
+            child_ppb.CommandLine.MaximumLength,
+            &size);
+    if (ret)
+        goto out;
+
+    size /= sizeof(WCHAR);
+    c = cmd_line = (char *)malloc(size + 256);
+    for (wc = cmd_line_w; wc < cmd_line_w + size; wc++) {
+#if 1
+        if (in_app_name > 1) {
+            *c++ = (unsigned char)*wc;
+        }
+        if (*wc == (WCHAR)'"') {
+            if (!in_app_name)
+                app_name_w = wc + 1;
+            else {
+                UNICODE_STRING nt_name;
+                ANSI_STRING unix_name = {0, 0, NULL};
+
+                /* change NT file name to Linux name */
+                *wc++ = (WCHAR)0;
+                if (!RtlDosPathNameToNtPathName_U(app_name_w, &nt_name, NULL, NULL))
+                    goto out;
+                if (wine_nt_to_unix_file_name(&nt_name, &unix_name, FILE_OPEN, FALSE)) {
+                    RtlFreeUnicodeString(&nt_name);
+                    goto out;
+                }
+                memcpy(cmd_line, unix_name.Buffer, unix_name.Length);
+                cmd_line[unix_name.Length] = 0;
+                c += unix_name.Length + 1;
+                p = c;
+                RtlFreeAnsiString(&unix_name);
+            }
+            in_app_name++;
+        }
+#else
+        *c = (unsigned char)*wc;
+        if (*c != '"')
+            c++;
+#endif
+    }
+    *c = 0;
+
+    argv = (char **)malloc(size * sizeof(char *));
+    argv[argc++] = cmd_line;
+    if (!p)
+        p = cmd_line;
+    while ((c = strchr(p, ' '))) {
+        *c = 0;
+        if (p != cmd_line)
+            argv[argc++] = p;
+        p = c + 1;
+    }
+    argv[argc++] = p;
+    argv[argc] = NULL;
+
+    env_start = (unsigned long)*envp;
+    while (*envp++) {
+        envc++;
+    }
+    envp -= 2;
+
+    /* envp --> auxvec, envp - 1 --> 0 */
+    env_end = (unsigned long)*envp;	
+    if (strncmp(*envp, "_=", 2))
+        env_end += strlen((PVOID)env_end) + 1;
+    else {
+        last_env = (char *)malloc(strlen(argv[0]) + 2 + 1);
+        sprintf(last_env, "_=%s", argv[0]);
+    }
+
+    /* fill stack */
+    stack_u = malloc(DEFAULT_COMMIT_SIZE + PAGE_SIZE);
+    stack = (void *)(((unsigned long)stack_u + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));
+    p =(char *)((unsigned long)stack + DEFAULT_COMMIT_SIZE - sizeof(void *));
+
+    /* copy argv0 */
+    p -= strlen(*argv) + 1;
+    memcpy(p, *argv, strlen(*argv) + 1);
+
+    /* copy environ */
+    if (last_env) {
+        size = strlen(last_env) + 1;
+        p -= size;
+        memcpy(p, last_env, size);
+    }
+    size = env_end - env_start;
+    p -= size;
+    memcpy(p, (PVOID)env_start, size);
+    child_env = p;
+
+    /* copy cmd line */
+    i = argc;
+    while (--i >= 0) {
+        p -= strlen(argv[i]) + 1;
+        memcpy(p, argv[i], strlen(argv[i]) + 1);
+    }
+    child_argv = p;
+    size = auxvec_len;
+    p -= size;
+
+    size = (argc + 1 + envc + 1 + 1) * sizeof(unsigned long);
+    p = (char *)(((unsigned long)p - size) & ~15);
+    child_stack_start = p;
+    p = child_stack_start + size;
+    memcpy(p, (void *)auxvec, auxvec_len);
+    p = child_stack_start;
+
+    *(int *)p = argc;
+    p += sizeof(int);
+    i = argc;
+    c = child_argv;
+    while (--i >= 0) {
+        *(unsigned long *)p = (unsigned long)c;
+        c += strlen(c) + 1;
+        p += sizeof(unsigned long);
+    }
+    *(int *)p = 0;
+    p += sizeof(int *);
+    i = envc;
+    c = child_env;
+    while (--i >= 0) {
+        *(unsigned long *)p = (unsigned long)c;
+        c += strlen(c) + 1;
+        p += sizeof(unsigned long);
+    }
+    *(int *)p = 0;
+    p += sizeof(int);
+
+    InitialTeb->StackReserved = InitialTeb->StackBase;
+    size = DEFAULT_COMMIT_SIZE - (child_stack_start - (char *)stack);
+    InitialTeb->StackBase = (PVOID)((unsigned long)InitialTeb->StackBase - size);
+
+    delta = (unsigned long)InitialTeb->StackBase - (unsigned long)child_stack_start;
+    argc = *(int *)child_stack_start;
+    tmp = (char **)((int *)child_stack_start + 1);
+
+    for (i = 0; i < argc; i++)
+        tmp[i] += delta;
+
+    envp = tmp + argc + 1;
+    tmp = envp;
+    while (*tmp) {
+        *tmp += delta;
+        tmp++;
+    }
+
+    ret = NtWriteVirtualMemory(ProcessHandle,
+            InitialTeb->StackBase,
+            child_stack_start,
+            size,
+            &size_out
+            );
+    if (ret)
+        goto out;
+
+out:
+    if (cmd_line_w)
+        free(cmd_line_w);
+    if (cmd_line)
+        free(cmd_line);
+    if (last_env)
+        free(last_env);
+    if (stack_u)
+        free(stack_u);
+    if (argv)
+        free(argv);
+
+    return ret;
+}
+
+extern NTSTATUS WINAPI NtResumeThread( HANDLE handle, PULONG count );
+extern void *_dl_allocate_tls(void *);
+
+NTSTATUS CDECL
+RtlRosCreateUserThread(IN HANDLE ProcessHandle,
+        IN POBJECT_ATTRIBUTES ObjectAttributes,
+        IN BOOLEAN CreateSuspended,
+        IN LONG StackZeroBits,
+        IN OUT PULONG StackReserve OPTIONAL,
+        IN OUT PULONG StackCommit OPTIONAL,
+        IN PVOID BaseStartAddress,
+        OUT PHANDLE ThreadHandle OPTIONAL,
+        OUT PCLIENT_ID ClientId OPTIONAL,
+        IN ULONG_PTR StartAddress,
+        IN ULONG_PTR Parameter)
+{
+    INITIAL_TEB usUserInitialTeb;
+    CONTEXT ctxInitialContext;
+    NTSTATUS nErrCode;
+    int request_pipe[2];
+    struct ntdll_thread_data *thread_data;
+    THREAD_BASIC_INFORMATION thread_info;
+    TEB * teb;
+    HANDLE wine_handle;
+    BOOLEAN suspend;
+
+    if (!ClientId) {
+        CLIENT_ID cid;
+        ClientId = &cid;
+    }
+    /* allocate the stack for the thread */
+    nErrCode = RtlRosCreateStack(ProcessHandle,
+            &usUserInitialTeb,
+            StackZeroBits,
+            StackReserve,
+            StackCommit);
+
+    /* filure */
+    if(nErrCode) 
+        goto l_Fail;
+
+    if (!BaseStartAddress) {
+        nErrCode = RtlRosInitializeStack(ProcessHandle, &usUserInitialTeb);
+        if (nErrCode)
+            goto l_Fail;
+    } else {
+        struct pthread *pthread, *parent_pthread;
+        unsigned long pthread_size;
+
+        asm("movl %%gs:8, %0\n" : "=r"(parent_pthread));
+
+        pthread_size = (((unsigned long)parent_pthread + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)) - (unsigned long)parent_pthread;
+        pthread = (struct pthread *)((unsigned long)usUserInitialTeb.StackBase - 0x800);
+        memcpy((void *)pthread, (void *)parent_pthread, pthread_size);
+
+        _dl_allocate_tls((void *)pthread);
+
+        pthread->header.tcb = pthread;
+        pthread->header.self = pthread;
+        pthread->header.multiple_threads = 1;
+        pthread->specific[0] = pthread->specific_1stblock;
+        pthread->user_stack = 1;
+        pthread->stackblock = (void *)((unsigned long)usUserInitialTeb.StackBase + PAGE_SIZE - DEFAULT_STACK_SIZE);
+        pthread->stackblock_size = DEFAULT_STACK_SIZE;
+        pthread->guardsize = pthread->reported_guardsize = DEFAULT_GUARD_SIZE / PAGE_SIZE;
+        pthread->list.next = &pthread->list;
+        pthread->list.prev = &pthread->list;
+
+        usUserInitialTeb.StackBase = (void *)((unsigned long)usUserInitialTeb.StackBase - PAGE_SIZE);
+    }
+
+    /* initialize the registers and stack for the thread */
+    nErrCode = RtlRosInitializeContext(ProcessHandle,
+            &ctxInitialContext,
+            BaseStartAddress,
+            &usUserInitialTeb,
+            StartAddress,
+            Parameter);
+
+    /* failure */
+    if(nErrCode)
+        goto l_Fail;
+
+    if(BaseStartAddress) suspend = 1;
+    else suspend = CreateSuspended;
+
+    /* create the thread object */
+    nErrCode = NtCreateThread(ThreadHandle,
+            THREAD_ALL_ACCESS,
+            ObjectAttributes,
+            ProcessHandle,
+            ClientId,
+            &ctxInitialContext,
+            &usUserInitialTeb,
+            suspend);
+
+    /* failure */
+    if(nErrCode)
+        goto l_Fail;
+
+    if(BaseStartAddress) {
+        if (-1 == pipe(request_pipe))
+            return STATUS_TOO_MANY_OPENED_FILES;
+
+        /* set close on exec flag */
+        fcntl(request_pipe[1], F_SETFD, 1);
+        wine_server_send_fd(request_pipe[0]);
+
+        SERVER_START_REQ( new_thread )
+        {
+            req->access     = THREAD_ALL_ACCESS;
+            req->attributes = 0;  /* FIXME */
+            req->suspend    = suspend;
+            req->request_fd = request_pipe[0];
+            req->tid = (int) ClientId->UniqueThread;
+            nErrCode = wine_server_call(req);
+
+            wine_handle = reply->handle;
+            close(request_pipe[0]);
+        }
+        SERVER_END_REQ;
+
+        if(nErrCode)
+            goto l_Fail;
+
+        if (!store_handle_pair(*ThreadHandle, wine_handle))
+            goto l_Fail;
+
+        NtQueryInformationThread((*ThreadHandle), 0, &thread_info, sizeof(thread_info), NULL);
+        teb = thread_info.TebBaseAddress;
+        teb->ClientId.UniqueThread = teb->RealClientId.UniqueThread;
+        teb->ClientId.UniqueProcess = teb->RealClientId.UniqueProcess;	
+
+        /* initialize some fields in teb and peb */
+        teb->StaticUnicodeString.Length        = 0;
+        teb->StaticUnicodeString.Buffer        = teb->StaticUnicodeBuffer;
+        teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
+
+        thread_data = (struct ntdll_thread_data *)teb->SystemReserved2;
+        thread_data->request_fd  = request_pipe[1];
+        thread_data->reply_fd   = -1;
+        thread_data->wait_fd[0] = -1;
+        thread_data->wait_fd[1] = -1;
+
+        if(!CreateSuspended) NtResumeThread((*ThreadHandle), NULL);
+    }
+    /* success */
+    return STATUS_SUCCESS;
+
+    /* failure */
+l_Fail:
+    assert(nErrCode);
+
+    /* deallocate the stack */
+    RtlRosDeleteStack(ProcessHandle, &usUserInitialTeb);
+    close(request_pipe[1]);
+
+    return nErrCode;
+}
+#endif
 
 /***********************************************************************
  *           RtlExitUserThread  (NTDLL.@)
@@ -618,6 +1471,7 @@
 {
     NTSTATUS ret;
 
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( open_thread )
     {
         req->tid        = HandleToULong(id->UniqueThread);
@@ -627,6 +1481,35 @@
         *handle = reply->handle;
     }
     SERVER_END_REQ;
+#else
+    PHANDLE uk_handle = handle;
+    HANDLE wine_handle;
+
+    __asm__ __volatile__ (
+            "movl $0x64,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );	
+
+    if (!ret)
+    {
+        SERVER_START_REQ( open_thread)
+        {
+            req->tid        = (thread_id_t)id->UniqueThread;
+            req->access     = access;
+            req->attributes = attr ? attr->Attributes : 0;
+            ret = wine_server_call( req );
+            if (!ret) 
+            {
+                wine_handle = reply->handle;
+                if (!store_handle_pair(*uk_handle, wine_handle))
+                    return STATUS_NO_MEMORY;
+            }
+        }
+        SERVER_END_REQ;
+    }
+#endif
     return ret;
 }
 
@@ -639,12 +1522,36 @@
 {
     NTSTATUS ret;
 
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( suspend_thread )
     {
         req->handle = handle;
         if (!(ret = wine_server_call( req ))) *count = reply->count;
     }
     SERVER_END_REQ;
+#else
+    HANDLE wine_handle = GetCurrentThread();
+    struct handle_pair * pair;
+
+    __asm__ __volatile__ (
+            "movl $0xD0,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    if (!ret) {
+        pair = search_handle_pair(handle);
+        if(pair)
+            wine_handle = pair->wine_handle;
+
+        SERVER_START_REQ( suspend_thread )
+        {
+            req->handle = wine_handle;
+            wine_server_call( req );
+        }
+        SERVER_END_REQ;
+    }
+#endif
     return ret;
 }
 
@@ -657,12 +1564,37 @@
 {
     NTSTATUS ret;
 
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( resume_thread )
     {
         req->handle = handle;
         if (!(ret = wine_server_call( req ))) *count = reply->count;
     }
     SERVER_END_REQ;
+#else
+    HANDLE wine_handle = GetCurrentThread();
+    struct handle_pair * pair;
+
+    pair = search_handle_pair(handle);
+    if(pair)
+        wine_handle = pair->wine_handle;
+
+    SERVER_START_REQ( resume_thread )
+    {
+        req->handle = wine_handle;
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (!ret) {
+        __asm__ __volatile__ (
+                "movl $0xA8,%%eax\n\t"
+                "lea 8(%%ebp),%%edx\n\t"
+                "int $0x2E\n\t"
+                :"=a" (ret)
+                );
+    }
+#endif
     return ret;
 }
 
@@ -696,6 +1628,7 @@
 NTSTATUS WINAPI NtTerminateThread( HANDLE handle, LONG exit_code )
 {
     NTSTATUS ret;
+#ifndef UNIFIED_KERNEL
     BOOL self, last;
 
     SERVER_START_REQ( terminate_thread )
@@ -713,6 +1646,13 @@
         if (last) exit( exit_code );
         else server_abort_thread( exit_code );
     }
+#else
+    __asm__ __volatile__ ( "movl $0xD4,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+#endif
     return ret;
 }
 
@@ -724,6 +1664,7 @@
                                   ULONG_PTR arg2, ULONG_PTR arg3 )
 {
     NTSTATUS ret;
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( queue_apc )
     {
         req->thread = handle;
@@ -739,6 +1680,14 @@
         ret = wine_server_call( req );
     }
     SERVER_END_REQ;
+#else
+    __asm__ __volatile__ (
+            "movl $0x95,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+#endif
     return ret;
 }
 
@@ -767,9 +1716,19 @@
 
     if (!self)
     {
+#ifdef UNIFIED_KERNEL
+        HANDLE wine_handle = NULL;
+        struct handle_pair * pair = search_handle_pair(handle);
+        if (pair)
+            wine_handle = pair->wine_handle;
+#endif
         SERVER_START_REQ( set_thread_context )
         {
+#ifndef UNIFIED_KERNEL
             req->handle  = handle;
+#else
+            req->handle  = wine_handle;
+#endif
             req->flags   = context->ContextFlags;
             req->suspend = 0;
             wine_server_add_data( req, context, sizeof(*context) );
@@ -1066,9 +2025,19 @@
 
     if (!self)
     {
+#ifdef UNIFIED_KERNEL
+        HANDLE wine_handle = NULL;
+        struct handle_pair * pair = search_handle_pair(handle);
+        if (pair)
+            handle = pair->wine_handle;
+#endif
         SERVER_START_REQ( get_thread_context )
         {
+#ifndef UNIFIED_KERNEL
             req->handle  = handle;
+#else
+            req->handle  = wine_handle;
+#endif
             req->flags   = context->ContextFlags;
             req->suspend = 0;
             wine_server_set_reply( req, &ctx, sizeof(ctx) );
@@ -1143,6 +2112,7 @@
 {
     NTSTATUS status;
 
+#ifndef UNIFIED_KERNEL
     switch(class)
     {
     case ThreadBasicInformation:
@@ -1319,6 +2289,15 @@
         FIXME( "info class %d not supported yet\n", class );
         return STATUS_NOT_IMPLEMENTED;
     }
+#else
+    __asm__ __volatile__ (
+            "movl $0x7E,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+    return status;
+#endif
 }
 
 
@@ -1330,6 +2309,7 @@
                                         LPCVOID data, ULONG length )
 {
     NTSTATUS status;
+#ifndef UNIFIED_KERNEL
     switch(class)
     {
     case ThreadZeroTlsCell:
@@ -1430,6 +2410,15 @@
         FIXME( "info class %d not supported yet\n", class );
         return STATUS_NOT_IMPLEMENTED;
     }
+#else
+    __asm__ __volatile__ (
+            "movl $0xBB,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+    return status;
+#endif
 }
 
 
@@ -1450,7 +2439,16 @@
 
 TEB * WINAPI NtCurrentTeb(void)
 {
+#ifndef UNIFIED_KERNEL
     return pthread_functions.get_current_teb();
+#else
+    TEB *ret;
+    __asm__ __volatile__ (
+            "movl %%fs:0x18, %0\n"
+            : "=r" (ret)
+            : /* no inputs */ );
+    return ret;
+#endif
 }
 
 #endif  /* __i386__ */
diff -urN wine-1.0/dlls/ntdll/threadpool.c wine-1.0-uk/dlls/ntdll/threadpool.c
--- wine-1.0/dlls/ntdll/threadpool.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/threadpool.c	2009-08-19 10:13:55.000000000 +0800
@@ -157,6 +157,22 @@
     return status;
 }
 
+#ifdef UNIFIED_KERNEL
+extern void (*ThreadStartup)(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter);
+extern NTSTATUS
+RtlRosCreateUserThread(IN HANDLE ProcessHandle,
+        IN POBJECT_ATTRIBUTES ObjectAttributes,
+        IN BOOLEAN CreateSuspended,
+        IN LONG StackZeroBits,
+        IN OUT PULONG StackReserve OPTIONAL,
+        IN OUT PULONG StackCommit OPTIONAL,
+        IN PVOID BaseStartAddress,
+        OUT PHANDLE ThreadHandle OPTIONAL,
+        OUT PCLIENT_ID ClientId OPTIONAL,
+        IN ULONG_PTR StartAddress,
+        IN ULONG_PTR Parameter);
+#endif
+
 /***********************************************************************
  *              RtlQueueWorkItem   (NTDLL.@)
  *
@@ -201,9 +217,15 @@
     if ((status == STATUS_SUCCESS) &&
         ((num_workers == 0) || (num_workers == num_busy_workers)))
     {
+#ifndef UNIFIED_KERNEL
         status = RtlCreateUserThread( GetCurrentProcess(), NULL, FALSE,
                                     NULL, 0, 0,
                                     worker_thread_proc, NULL, &thread, NULL );
+#else
+        status = RtlRosCreateUserThread(GetCurrentProcess(),
+                NULL, FALSE, 0, NULL, NULL, (PVOID)ThreadStartup,
+                &thread, NULL, (ULONG_PTR)worker_thread_proc, 0);
+#endif
         if (status == STATUS_SUCCESS)
             NtClose( thread );
 
diff -urN wine-1.0/dlls/ntdll/virtual.c wine-1.0-uk/dlls/ntdll/virtual.c
--- wine-1.0/dlls/ntdll/virtual.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/ntdll/virtual.c	2009-08-19 11:02:45.000000000 +0800
@@ -84,6 +84,11 @@
 #define VFLAG_SYSTEM     0x01  /* system view (underlying mmap not under our control) */
 #define VFLAG_VALLOC     0x02  /* allocated by VirtualAlloc */
 
+#ifdef UNIFIED_KERNEL
+extern NTSTATUS WINAPI
+NtWineService(struct __server_request_info * ReqMsg);
+#endif
+
 /* Conversion from VPROT_* to Win32 flags */
 static const BYTE VIRTUAL_Win32Flags[16] =
 {
@@ -399,7 +404,14 @@
  */
 static void delete_view( struct file_view *view ) /* [in] View */
 {
+#ifndef UNIFIED_KERNEL
     if (!(view->flags & VFLAG_SYSTEM)) unmap_area( view->base, view->size );
+#else
+    if (!(view->flags & VFLAG_SYSTEM)) {
+        unmap_area( view->base, view->size );
+        NtFreeVirtualMemory( NtCurrentProcess(), &view->base, &view->size, MEM_SYSTEM);
+    }
+#endif
     list_remove( &view->entry );
     if (view->mapping) NtClose( view->mapping );
     free( view );
@@ -481,6 +493,7 @@
 }
 
 
+#ifndef UNIFIED_KERNEL
 /***********************************************************************
  *           VIRTUAL_GetWin32Prot
  *
@@ -493,6 +506,7 @@
     if (vprot & VPROT_GUARD) ret |= PAGE_GUARD;
     return ret;
 }
+#endif
 
 
 /***********************************************************************
@@ -743,13 +757,22 @@
             }
             TRACE( "got mem with anon mmap %p-%p\n", ptr, (char *)ptr + size );
             /* if we got something beyond the user limit, unmap it and retry */
+#ifndef UNIFIED_KERNEL
             if (is_beyond_limit( ptr, view_size, user_space_limit )) add_reserved_area( ptr, view_size );
+#else
+            /* FIXME */
+            if (is_beyond_limit( ptr, view_size, (void *)0xc0000000 )) add_reserved_area( ptr, view_size );
+#endif
             else break;
         }
         ptr = unmap_extra_space( ptr, view_size, size, mask );
     }
 done:
     status = create_view( view_ret, ptr, size, vprot );
+#ifdef UNIFIED_KERNEL
+    status = NtAllocateVirtualMemory( NtCurrentProcess(), &ptr, 0, &size,
+                             MEM_SYSTEM, PAGE_NOACCESS );
+#endif
     if (status != STATUS_SUCCESS) unmap_area( ptr, size );
     return status;
 }
@@ -860,6 +883,7 @@
 }
 
 
+#ifndef UNIFIED_KERNEL
 /***********************************************************************
  *           decommit_view
  *
@@ -877,6 +901,7 @@
     }
     return FILE_GetNtStatus();
 }
+#endif
 
 
 /***********************************************************************
@@ -1373,6 +1398,7 @@
 NTSTATUS WINAPI NtAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG zero_bits,
                                          SIZE_T *size_ptr, ULONG type, ULONG protect )
 {
+#ifndef UNIFIED_KERNEL
     void *base;
     BYTE vprot;
     SIZE_T size = *size_ptr;
@@ -1489,6 +1515,16 @@
         *ret = base;
         *size_ptr = size;
     }
+#else
+    NTSTATUS status;
+
+    __asm__ __volatile__ (
+            "movl $0xB,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+#endif
     return status;
 }
 
@@ -1499,6 +1535,7 @@
  */
 NTSTATUS WINAPI NtFreeVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *size_ptr, ULONG type )
 {
+#ifndef UNIFIED_KERNEL
     FILE_VIEW *view;
     char *base;
     sigset_t sigset;
@@ -1583,6 +1620,16 @@
     }
 
     server_leave_uninterrupted_section( &csVirtual, &sigset );
+#else
+    NTSTATUS status;
+
+    __asm__ __volatile__ (
+            "movl $0x40,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+#endif
     return status;
 }
 
@@ -1594,6 +1641,7 @@
 NTSTATUS WINAPI NtProtectVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *size_ptr,
                                         ULONG new_prot, ULONG *old_prot )
 {
+#ifndef UNIFIED_KERNEL
     FILE_VIEW *view;
     sigset_t sigset;
     NTSTATUS status = STATUS_SUCCESS;
@@ -1668,6 +1716,16 @@
         *addr_ptr = base;
         *size_ptr = size;
     }
+#else
+    NTSTATUS status;
+
+    __asm__ __volatile__ (
+            "movl $0x6D,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+#endif
     return status;
 }
 
@@ -1684,6 +1742,7 @@
                                       MEMORY_INFORMATION_CLASS info_class, PVOID buffer,
                                       SIZE_T len, SIZE_T *res_len )
 {
+#ifndef UNIFIED_KERNEL
     FILE_VIEW *view;
     char *base, *alloc_base = 0;
     struct list *ptr;
@@ -1806,6 +1865,17 @@
     info->RegionSize     = size - (base - alloc_base);
     if (res_len) *res_len = sizeof(*info);
     return STATUS_SUCCESS;
+#else
+    NTSTATUS status;
+
+    __asm__ __volatile__ (
+            "movl $0x93,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+    return status;
+#endif
 }
 
 
@@ -1882,6 +1952,119 @@
     return status;
 }
 
+#ifdef UNIFIED_KERNEL
+NTSTATUS WINAPI UkCreateSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+        const LARGE_INTEGER *size, ULONG protect,
+        ULONG sec_flags, HANDLE file )
+{
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0x24,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+}
+
+NTSTATUS WINAPI UkOpenSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0x61,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+}
+
+NTSTATUS WINAPI UkMapViewOfSection( HANDLE handle, HANDLE process, PVOID *addr_ptr, ULONG zero_bits,
+        SIZE_T commit_size, const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr,
+        SECTION_INHERIT inherit, ULONG alloc_type, ULONG protect )
+{
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0x52,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+}
+
+NTSTATUS WINAPI UkUnmapViewOfSection( HANDLE process, PVOID addr )
+{
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0xdc,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+}
+
+NTSTATUS WINAPI UkQuerySection(
+        IN HANDLE SectionHandle,
+        IN SECTION_INFORMATION_CLASS SectionInformationClass,
+        OUT PVOID SectionInformation,
+        IN ULONG Length,
+        OUT PULONG ResultLength)
+{
+    NTSTATUS ret;
+    __asm__ __volatile__(
+            "movl $0x89,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+}
+
+NTSTATUS WINAPI UkAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG zero_bits,
+        SIZE_T *size_ptr, ULONG type, ULONG protect )
+{
+    NTSTATUS status;
+
+    __asm__ __volatile__ (
+            "movl $0xB,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+    return status;
+}
+
+NTSTATUS WINAPI UkWriteVirtualMemory( HANDLE process, void *addr, const void *buffer,
+        SIZE_T size, SIZE_T *bytes_written )
+{
+    NTSTATUS status;
+
+    __asm__ __volatile__ (
+            "movl $0xE5,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+    return status;      
+}                       
+
+NTSTATUS WINAPI UkReadVirtualMemory( HANDLE process, const void *addr, void *buffer,
+        SIZE_T size, SIZE_T *bytes_read )
+{       
+    NTSTATUS status;
+
+    __asm__ __volatile__ (
+            "movl $0x9B,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+    return status;
+}
+
+#endif
 
 /***********************************************************************
  *             NtCreateSection   (NTDLL.@)
@@ -1891,6 +2074,7 @@
                                  const LARGE_INTEGER *size, ULONG protect,
                                  ULONG sec_flags, HANDLE file )
 {
+#ifndef UNIFIED_SECTION
     NTSTATUS ret;
     BYTE vprot;
     DWORD len = (attr && attr->ObjectName) ? attr->ObjectName->Length : 0;
@@ -1931,7 +2115,11 @@
         wine_server_add_data( req, &objattr, sizeof(objattr) );
         if (objattr.sd_len) wine_server_add_data( req, sd, objattr.sd_len );
         if (len) wine_server_add_data( req, attr->ObjectName->Buffer, len );
+#ifndef UNIFIED_KERNEL
         ret = wine_server_call( req );
+#else
+        ret = NtWineService( req );
+#endif
         *handle = reply->handle;
     }
     SERVER_END_REQ;
@@ -1939,6 +2127,16 @@
     NTDLL_free_struct_sd( sd );
 
     return ret;
+#else
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0x24,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+#endif
 }
 
 
@@ -1948,6 +2146,7 @@
  */
 NTSTATUS WINAPI NtOpenSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
 {
+#ifndef UNIFIED_SECTION
     NTSTATUS ret;
     DWORD len = attr->ObjectName->Length;
 
@@ -1959,10 +2158,24 @@
         req->attributes = attr->Attributes;
         req->rootdir = attr->RootDirectory;
         wine_server_add_data( req, attr->ObjectName->Buffer, len );
+#ifndef UNIFIED_KERNEL
         if (!(ret = wine_server_call( req ))) *handle = reply->handle;
+#else
+        if (!(ret = NtWineService( req ))) *handle = reply->handle;
+#endif
     }
     SERVER_END_REQ;
     return ret;
+#else
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0x61,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+#endif
 }
 
 
@@ -1974,6 +2187,7 @@
                                     SIZE_T commit_size, const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr,
                                     SECTION_INHERIT inherit, ULONG alloc_type, ULONG protect )
 {
+#ifndef UNIFIED_SECTION
     NTSTATUS res;
     ULONGLONG full_size;
     SIZE_T size = 0;
@@ -2026,7 +2240,11 @@
     SERVER_START_REQ( get_mapping_info )
     {
         req->handle = handle;
+#ifndef UNIFIED_KERNEL
         res = wine_server_call( req );
+#else
+        res = NtWineService( req );
+#endif
         prot        = reply->protect;
         base        = reply->base;
         full_size   = reply->size;
@@ -2054,7 +2272,9 @@
                                            &shared_fd, &shared_needs_close, NULL, NULL ))) goto done;
             res = map_image( handle, unix_handle, base, size, mask, header_size,
                              shared_fd, dup_mapping, addr_ptr );
+#ifndef UNIFIED_KERNEL
             if (shared_needs_close) close( shared_fd );
+#endif
             NtClose( shared_file );
         }
         else
@@ -2062,7 +2282,9 @@
             res = map_image( handle, unix_handle, base, size, mask, header_size,
                              -1, dup_mapping, addr_ptr );
         }
+#ifndef UNIFIED_KERNEL
         if (needs_close) close( unix_handle );
+#endif
         if (!res) *size_ptr = size;
         return res;
     }
@@ -2142,8 +2364,19 @@
 
 done:
     if (dup_mapping) NtClose( dup_mapping );
+#ifndef UNIFIED_KERNEL
     if (needs_close) close( unix_handle );
+#endif
     return res;
+#else
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0x52,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+#endif
 }
 
 
@@ -2153,6 +2386,7 @@
  */
 NTSTATUS WINAPI NtUnmapViewOfSection( HANDLE process, PVOID addr )
 {
+#ifndef UNIFIED_SECTION
     FILE_VIEW *view;
     NTSTATUS status = STATUS_INVALID_PARAMETER;
     sigset_t sigset;
@@ -2180,6 +2414,16 @@
     }
     server_leave_uninterrupted_section( &csVirtual, &sigset );
     return status;
+#else
+    NTSTATUS ret;
+    __asm__ __volatile__ (
+            "movl $0xdc,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (ret)
+            );
+    return ret;
+#endif
 }
 
 
@@ -2190,6 +2434,7 @@
 NTSTATUS WINAPI NtFlushVirtualMemory( HANDLE process, LPCVOID *addr_ptr,
                                       SIZE_T *size_ptr, ULONG unknown )
 {
+#ifndef UNIFIED_KERNEL
     FILE_VIEW *view;
     NTSTATUS status = STATUS_SUCCESS;
     sigset_t sigset;
@@ -2225,6 +2470,16 @@
         if (msync( addr, *size_ptr, MS_SYNC )) status = STATUS_NOT_MAPPED_DATA;
     }
     server_leave_uninterrupted_section( &csVirtual, &sigset );
+#else
+    NTSTATUS status;
+
+    __asm__ __volatile__ (
+            "movl $0x3E,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+#endif
     return status;
 }
 
@@ -2238,6 +2493,7 @@
 {
     NTSTATUS status;
 
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( read_process_memory )
     {
         req->handle = process;
@@ -2247,6 +2503,14 @@
     }
     SERVER_END_REQ;
     if (bytes_read) *bytes_read = size;
+#else
+    __asm__ __volatile__ (
+            "movl $0x9B,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+#endif
     return status;
 }
 
@@ -2260,6 +2524,7 @@
 {
     NTSTATUS status;
 
+#ifndef UNIFIED_KERNEL
     SERVER_START_REQ( write_process_memory )
     {
         req->handle     = process;
@@ -2269,6 +2534,14 @@
     }
     SERVER_END_REQ;
     if (bytes_written) *bytes_written = size;
+#else
+    __asm__ __volatile__ (
+            "movl $0xE5,%%eax\n\t"
+            "lea 8(%%ebp),%%edx\n\t"
+            "int $0x2E\n\t"
+            :"=a" (status)
+            );
+#endif
     return status;
 }
 
@@ -2283,3 +2556,42 @@
 
     return STATUS_NOT_SAME_DEVICE;
 }
+
+#ifdef UNIFIED_KERNEL
+#define ALIGN_UP(addr, align)   (((addr) + (align) - 1) & ~((align) - 1))
+/*
+ * create_pe_sec_view
+ *
+ * create view for pe sections
+ */
+NTSTATUS create_pe_sec_view(HANDLE hmodule)
+{
+    IMAGE_NT_HEADERS *nt = RtlImageNtHeader(hmodule);
+    IMAGE_SECTION_HEADER *sec;
+    NTSTATUS status = 0;
+    struct file_view *view;
+    int i, sec_align;
+    void *virtual_addr;
+    size_t virtual_size, size = 0;
+
+    sec = (IMAGE_SECTION_HEADER *)((char *)&nt->OptionalHeader+nt->FileHeader.SizeOfOptionalHeader);
+    sec_align = nt->OptionalHeader.SectionAlignment;
+
+    virtual_init();
+
+    size = ALIGN_UP(sec->VirtualAddress, sec_align);
+    for (i=0; i<nt->FileHeader.NumberOfSections; i++, sec++) {
+        virtual_size = ALIGN_UP(sec->Misc.VirtualSize, sec_align);
+        size += virtual_size;
+    }
+
+    virtual_addr = (void *)ALIGN_UP((ULONG)hmodule, sec_align);
+    status = create_view(&view, virtual_addr, size,
+            VPROT_READ | VPROT_WRITECOPY | VPROT_EXEC | VPROT_COMMITTED);
+    if (status != STATUS_SUCCESS)
+        return status;
+
+    view->flags |= VFLAG_VALLOC;
+    return status;
+}
+#endif
diff -urN wine-1.0/dlls/user32/defwnd.c wine-1.0-uk/dlls/user32/defwnd.c
--- wine-1.0/dlls/user32/defwnd.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/user32/defwnd.c	2009-08-18 16:11:13.000000000 +0800
@@ -439,7 +439,9 @@
         else
         {
             RedrawWindow( hwnd, NULL, 0, RDW_ALLCHILDREN | RDW_VALIDATE );
+#ifndef UNIFIED_KERNEL /* FIXME */
             WIN_SetStyle( hwnd, 0, WS_VISIBLE );
+#endif
         }
         return 0;
 
diff -urN wine-1.0/dlls/user32/dialog.c wine-1.0-uk/dlls/user32/dialog.c
--- wine-1.0/dlls/user32/dialog.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/user32/dialog.c	2009-08-18 16:11:13.000000000 +0800
@@ -588,7 +588,11 @@
     if (modal)
     {
         ownerEnabled = DIALOG_DisableOwner( owner );
+#ifndef UNIFIED_KERNEL
         if (ownerEnabled) flags |= DF_OWNERENABLED;
+#else
+        if (ownerEnabled || owner == GetActiveWindow()) flags |= DF_OWNERENABLED;
+#endif
     }
 
     if (unicode)
diff -urN wine-1.0/dlls/user32/edit.c wine-1.0-uk/dlls/user32/edit.c
--- wine-1.0/dlls/user32/edit.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/user32/edit.c	2009-08-18 16:11:13.000000000 +0800
@@ -2595,16 +2595,38 @@
 			while (index && (s[index] == ' '))
 				index--;
 			if (index) {
+#ifndef UNIFIED_KERNEL /* modified for 16-bit character break */
 				while (index && (s[index] != ' '))
 					index--;
 				if (s[index] == ' ')
 					index++;
+#else
+				if (!(s[index] & 0xFF00)) {
+					while (index && (s[index] != ' ') && !(s[index] & 0xFF00))
+						index--;
+					if (s[index] & 0xFF00)
+						index++;
+				}
+				if (s[index] == ' ')
+					index++;
+#endif
 			}
 		} else {
+#ifndef UNIFIED_KERNEL /* modified for 16-bit character break */
 			while (index && (s[index] != ' '))
 				index--;
 			if (s[index] == ' ')
 				index++;
+#else
+			if (!(s[index] & 0xFF00)) {
+				while (index && (s[index] != ' ') && !(s[index] & 0xFF00))
+					index--;
+				if (s[index] & 0xFF00)
+					index++;
+			}
+			if (s[index] == ' ')
+				index++;
+#endif
 		}
 		ret = index;
 		break;
@@ -2616,8 +2638,17 @@
 		if (s[index] == ' ')
 			while ((index < count) && (s[index] == ' ')) index++;
 		else {
+#ifndef UNIFIED_KERNEL /* modified for 16-bit character break */
 			while (s[index] && (s[index] != ' ') && (index < count))
 				index++;
+#else
+			if (!(s[index] & 0xFF00))
+				while (s[index] && (s[index] != ' ') 
+						&& (index < count) && !(s[index] & 0xFF00))
+					index++;
+			else
+				index++;
+#endif
 			while ((s[index] == ' ') && (index < count)) index++;
 		}
 		ret = index;
diff -urN wine-1.0/dlls/user32/mdi.c wine-1.0-uk/dlls/user32/mdi.c
--- wine-1.0/dlls/user32/mdi.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/user32/mdi.c	2009-08-18 16:11:13.000000000 +0800
@@ -1884,8 +1884,85 @@
 CascadeWindows (HWND hwndParent, UINT wFlags, const RECT *lpRect,
 		UINT cKids, const HWND *lpKids)
 {
+#ifndef UNIFIED_KERNEL
     FIXME("(%p,0x%08x,...,%u,...): stub\n", hwndParent, wFlags, cKids);
     return 0;
+#else
+    MDICLIENTINFO *ci;
+    HWND *win_array;
+    BOOL has_icons = FALSE;
+    int i, total;
+
+    if(!(ci = get_client_info( hwndParent ))) return 0;
+
+    if (ci->hwndChildMaximized)
+        SendMessageW(hwndParent, WM_MDIRESTORE, (WPARAM)ci->hwndChildMaximized, 0);
+
+    if (!(win_array = WIN_ListChildren( hwndParent ))) 
+    {
+        HeapFree( GetProcessHeap(), 0, ci );
+        return 0;
+    }
+
+    /* remove all the windows we don't want */
+    for (i = total = 0; win_array[i]; i++)
+    {
+        if (!IsWindowVisible( win_array[i] )) continue;
+        if (GetWindow( win_array[i], GW_OWNER )) continue; /* skip owned windows */
+        if (IsIconic( win_array[i] ))
+        {
+            has_icons = TRUE;
+            continue;
+        }
+
+        total++;
+    }
+    HeapFree( GetProcessHeap(), 0, win_array );
+
+    if(lpKids) 
+    {
+        if (ci->nActiveChildren == 0)
+        {
+            HeapFree( GetProcessHeap(), 0, ci );
+            return 0;
+        }
+
+        if (cKids)
+        {
+            HWND *tmpid;
+            INT delta = 0, n = 0, i;
+            POINT pos[2];
+
+            if (has_icons) 
+                delta = GetSystemMetrics(SM_CYICONSPACING) + GetSystemMetrics(SM_CYICON);
+
+            tmpid = (HWND *)lpKids;
+            /* walk the list (backwards) and move windows */
+            for (i = cKids - 1; i >= 0; i--)
+            {
+                TRACE("move %p to (%d,%d) size [%d,%d]\n",
+                        tmpid[i], pos[0].x, pos[0].y, pos[1].x, pos[1].y);
+
+                MDI_CalcDefaultChildPos(hwndParent, n++, pos, delta, NULL);
+                SetWindowPos( tmpid[i], 0, pos[0].x, pos[0].y, pos[1].x, pos[1].y,
+                        SWP_DRAWFRAME | SWP_NOACTIVATE | SWP_NOZORDER);
+            }
+        }
+
+        if (has_icons) ArrangeIconicWindows( hwndParent);
+
+        HeapFree( GetProcessHeap(), 0, ci );
+        return cKids;
+    }
+    else
+    {
+        /* cascade child windows */
+        MDICascade(hwndParent, ci);
+
+        HeapFree( GetProcessHeap(), 0, ci );
+        return total;
+    }
+#endif
 }
 
 
@@ -1909,8 +1986,98 @@
 TileWindows (HWND hwndParent, UINT wFlags, const RECT *lpRect,
 	     UINT cKids, const HWND *lpKids)
 {
+#ifndef UNIFIED_KERNEL
     FIXME("(%p,0x%08x,...,%u,...): stub\n", hwndParent, wFlags, cKids);
     return 0;
+#else
+    /* Arrange child windows horizontally or vertically
+       Compare child windows abreast */
+    MDICLIENTINFO *ci;
+    HWND hwndChild;
+    BOOL has_icons = FALSE;
+    int total;
+
+    if (!(ci = get_client_info(hwndParent)))
+        return 0;
+
+    for (hwndChild = GetTopWindow(hwndParent), total = 0; hwndChild != NULL;
+            hwndChild = GetNextWindow(hwndChild, GW_HWNDNEXT)) {
+        if (!IsWindowVisible(hwndChild))
+            continue;
+        if (GetWindow(hwndChild, GW_OWNER))
+            continue;
+        if (IsIconic(hwndChild)) {
+            has_icons = TRUE;
+            continue;
+        }
+        if ((wFlags & MDITILE_SKIPDISABLED) && !IsWindowEnabled(hwndChild))
+            continue;
+
+        total++;
+    }
+
+    if (!lpKids) {
+        MDITile(hwndParent, ci, wFlags);
+
+        HeapFree(GetProcessHeap(), 0, ci);
+        return total;
+    }
+    else {
+        /* Refered to MDITile() */
+        HWND *pWnd = (HWND *)lpKids;
+        RECT rect;
+        int x, y, xsize, ysize;
+        int rows, columns, r, c, i;
+
+        if (cKids <= 0) {
+            HeapFree(GetProcessHeap(), 0, ci);
+            return 0;
+        }
+
+        if (ci->hwndChildMaximized)
+            SendMessageW(hwndParent, WM_MDIRESTORE, (WPARAM)ci->hwndChildMaximized, 0);
+
+        GetClientRect(hwndParent, &rect);
+        rows = (int)sqrt((double)cKids);
+        columns = cKids / rows;
+
+        if (wFlags & MDITILE_HORIZONTAL) {
+            i = rows;
+            rows = columns;
+            columns = i;
+        }
+
+        if (has_icons) {
+            y = rect.bottom - 2 * GetSystemMetrics(SM_CYICONSPACING) 
+                - GetSystemMetrics(SM_CYICON);
+            rect.bottom = (y - GetSystemMetrics(SM_CYICON) < rect.top) ? rect.bottom : y;
+        }
+
+        ysize = rect.bottom / rows;
+        xsize = rect.right / columns;
+
+        for (x = i = 0, c = 1; c <= columns && *pWnd; c++) {
+            if (c == columns) {
+                rows = cKids - i;
+                ysize = rect.bottom / rows;
+            }
+
+            y = 0;
+            for (r = 1; r <= rows && *pWnd; r++, i++) {
+                SetWindowPos(*pWnd, 0, x, y, xsize, ysize,
+                        SWP_DRAWFRAME | SWP_NOACTIVATE | SWP_NOZORDER);
+                y += ysize;
+                pWnd++;
+            }
+            x += xsize;
+        }
+        HeapFree(GetProcessHeap(), 0, ci);
+
+        if (has_icons)
+            ArrangeIconicWindows(hwndParent);
+        return cKids;
+    }
+#endif
 }
 
 
diff -urN wine-1.0/dlls/user32/message.c wine-1.0-uk/dlls/user32/message.c
--- wine-1.0/dlls/user32/message.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/user32/message.c	2009-08-18 16:11:13.000000000 +0800
@@ -43,6 +43,9 @@
 #include "win.h"
 #include "controls.h"
 #include "wine/debug.h"
+#ifdef UNIFIED_KERNEL
+#include "handle.h"
+#endif
 
 WINE_DEFAULT_DEBUG_CHANNEL(msg);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
@@ -3254,6 +3257,11 @@
     DWORD start_time, elapsed, ret;
     HANDLE handles[2];
 
+#ifdef UNIFIED_KERNEL
+    struct handle_pair* pair = search_handle_pair(hProcess);
+    if (pair)
+        hProcess = pair->wine_handle;
+#endif
     handles[0] = hProcess;
     SERVER_START_REQ( get_process_idle_event )
     {
diff -urN wine-1.0/dlls/user32/text.c wine-1.0-uk/dlls/user32/text.c
--- wine-1.0/dlls/user32/text.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/user32/text.c	2009-08-18 16:11:13.000000000 +0800
@@ -367,10 +367,38 @@
         ; /* we pretend that it fits anyway */
     else if (*p == SPACE) /* chars_fit < *len_str so this is valid */
         p--; /* the word just fitted */
+#ifdef UNIFIED_KERNEL
+    else if (*p >= 0x2e81 && *p <= 0xffe5) 
+    {
+        /* Chinese punctuation character: , . ? ! ) >> ' ' " ; : */
+        if (
+                *p == 0x2018 /* ) */
+            || *p == 0x2019 /* ! */
+                || *p == 0x201D /* ? */
+                || *p == 0x3002 /* ; */
+                || *p == 0x300B /* >> */
+                || *p == 0xFF01 /* '(right) */
+                || *p == 0xFF09 /* '(left) */
+                || *p == 0xFF0C /* : */
+                || *p == 0xFF1A /* , */
+                || *p == 0xFF1B /* . */
+                || *p == 0xFF1F /* "(right) */
+                )
+                p--;
+        /* CJK characters are treated breakable */
+        p--;
+    }
+#endif
     else
     {
+#ifndef UNIFIED_KERNEL
         while (p > str && *(--p) != SPACE)
             ;
+#else
+        /*  if Chinese and English mix up */
+        while (p > str && *p != SPACE && (*p < 0x3012 || *p > 0xFA29 ) )
+            p--;
+#endif
         word_fits = (p != str || *p == SPACE);
     }
     /* If there was one or the first character didn't fit then */
diff -urN wine-1.0/dlls/user32/winpos.c wine-1.0-uk/dlls/user32/winpos.c
--- wine-1.0/dlls/user32/winpos.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/user32/winpos.c	2009-08-18 16:11:13.000000000 +0800
@@ -859,6 +859,10 @@
     POINT size;
     LONG old_style;
     WINDOWPLACEMENT wpl;
+#ifdef UNIFIED_KERNEL
+    HWND parent;
+    RECT parent_rect;
+#endif
 
     TRACE("%p %u\n", hwnd, cmd );
 
@@ -913,7 +917,16 @@
         if (old_style & WS_MINIMIZE) WINPOS_ShowIconTitle( hwnd, FALSE );
 
         if (!(old_style & WS_MAXIMIZE)) swpFlags |= SWP_STATECHANGED;
+#ifdef UNIFIED_KERNEL
+        parent = GetWindowRect((HWND)GetWindowLongW(hwnd, GWLP_HWNDPARENT), &parent_rect);
+        if (parent)
+            SetRect( rect, wpl.ptMaxPosition.x, wpl.ptMaxPosition.y,
+                    parent_rect.right - parent_rect.left, parent_rect.bottom - parent_rect.top);
+        else
+            SetRect( rect, wpl.ptMaxPosition.x, wpl.ptMaxPosition.y, size.x, size.y );
+#else
         SetRect( rect, wpl.ptMaxPosition.x, wpl.ptMaxPosition.y, size.x, size.y );
+#endif
         break;
 
     case SW_SHOWNOACTIVATE:
diff -urN wine-1.0/dlls/winex11.drv/event.c wine-1.0-uk/dlls/winex11.drv/event.c
--- wine-1.0/dlls/winex11.drv/event.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/winex11.drv/event.c	2009-08-18 16:11:13.000000000 +0800
@@ -334,7 +334,14 @@
     while (XCheckIfEvent( display, &event, filter, (char *)arg ))
     {
         count++;
+#ifndef UNIFIED_KERNEL
         if (XFilterEvent( &event, None )) continue;  /* filtered, ignore it */
+#else
+        if(event.type != KeyRelease)  /* do not filter key release event */
+        {
+            if (XFilterEvent( &event, None )==True) continue;  /* filtered, ignore it */
+        }
+#endif
         if (prev_event.type) action = merge_events( &prev_event, &event );
         switch( action )
         {
diff -urN wine-1.0/dlls/winex11.drv/text.c wine-1.0-uk/dlls/winex11.drv/text.c
--- wine-1.0/dlls/winex11.drv/text.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/winex11.drv/text.c	2009-08-18 16:11:13.000000000 +0800
@@ -51,8 +51,155 @@
     BOOL                result = TRUE;
     HRGN                saved_region = 0;
 
+#ifndef UNIFIED_KERNEL
     if(physDev->has_gdi_font)
         return X11DRV_XRender_ExtTextOut(physDev, x, y, flags, lprect, wstr, count, lpDx);
+#else
+    if(physDev->has_gdi_font)
+    {
+        HDC hdc;
+        TEXTMETRICW tmw;
+
+        /* get tmw */
+        hdc = physDev->hdc;
+        GetTextMetricsW(hdc, &tmw);
+
+        if (!(flags & ETO_ROTATE))
+        {
+            if(flags & ETO_BOLD_FLAG1)
+            {
+                X11DRV_XRender_ExtTextOut(physDev, x + 1, y, flags, lprect, 
+                        wstr, count, lpDx); 
+            }
+            /* if font is bold ,the draw text twice or more! */
+            if(flags & ETO_BOLD_FLAG2)
+            {
+                int font_heigh;
+                font_heigh = (int)(tmw.tmHeight / 210);
+                /* judge font heignt */
+                if(tmw.tmHeight <= 210)
+                {
+                    X11DRV_XRender_ExtTextOut(physDev, x + 1, y, flags, lprect, 
+                            wstr, count, lpDx);
+                }
+                else if(tmw.tmHeight <= 410 )
+                {
+                    while(font_heigh)
+                    {
+                        X11DRV_XRender_ExtTextOut(physDev, x + (int)(font_heigh * 1), 
+                                y + (int)(font_heigh * 0.3), 
+                                flags, lprect, wstr, count, lpDx);
+
+                        --font_heigh;
+                    }
+
+                }
+                else if(tmw.tmHeight <= 720)
+                {
+                    while(font_heigh)
+                    {
+                        X11DRV_XRender_ExtTextOut(physDev, x + (int)(font_heigh * 0.7), 
+                                y + (int)(font_heigh * 0.3), 
+                                flags, lprect, wstr, count, lpDx);
+
+                        --font_heigh;
+                    }
+                } 
+                else
+                {
+                    font_heigh = (font_heigh*0.5); 
+                    while(font_heigh)
+                    {
+                        X11DRV_XRender_ExtTextOut(physDev, x + (int)(font_heigh * 0.5), 
+                                y + (int)(font_heigh * 0.25), 
+                                flags, lprect, wstr, count, lpDx);
+                        X11DRV_XRender_ExtTextOut(physDev, x - (int)(font_heigh * 0.5), 
+                                y - (int)(font_heigh * 0.25), 
+                                flags, lprect, wstr, count, lpDx);
+                        /* prettier
+                           X11DRV_XRender_ExtTextOut(physDev, x + (int)(font_heigh * 0.5), y, 
+                           flags, lprect, wstr, count, lpDx);
+                           X11DRV_XRender_ExtTextOut(physDev, x - (int)(font_heigh * 0.5), y, 
+                           flags, lprect, wstr, count, lpDx);
+                           X11DRV_XRender_ExtTextOut(physDev, x, y + (int)(font_heigh * 0.25), 
+                           flags, lprect, wstr, count, lpDx);
+                           X11DRV_XRender_ExtTextOut(physDev, x, y - (int)(font_heigh * 0.25), 
+                           flags, lprect, wstr, count, lpDx);
+                           */
+                        --font_heigh;
+                    }
+                }
+            } /* end bold_flag2 */
+        } /* if !rotate */
+        else
+        {
+            if(flags & ETO_BOLD_FLAG1)
+            {
+                X11DRV_XRender_ExtTextOut(physDev, x, y + 1, flags, lprect, 
+                        wstr, count, lpDx); 
+            }
+            /* if font is bold ,the draw text twice or more! */
+            if(flags & ETO_BOLD_FLAG2)
+            {
+                int font_heigh;
+                font_heigh = (int)(tmw.tmHeight / 210);
+                /* judge font heignt */
+                if(tmw.tmHeight <= 210)
+                {
+                    X11DRV_XRender_ExtTextOut(physDev, x, y + 1, flags, lprect, wstr, count, lpDx);
+                }
+                else if(tmw.tmHeight <= 410 )
+                {
+                    while(font_heigh)
+                    {
+                        X11DRV_XRender_ExtTextOut(physDev, x + (int)(font_heigh * 0.3), 
+                                y + (int)(font_heigh * 1), 
+                                flags, lprect, wstr, count, lpDx);
+
+                        --font_heigh;
+                    }
+
+                }
+                else if(tmw.tmHeight <= 720)
+                {
+                    while(font_heigh)
+                    {
+                        X11DRV_XRender_ExtTextOut(physDev, x + (int)(font_heigh * 0.3), 
+                                y + (int)(font_heigh * 0.7), 
+                                flags, lprect, wstr, count, lpDx);
+
+                        --font_heigh;
+                    }
+                } 
+                else
+                {
+                    font_heigh = (font_heigh*0.5); 
+                    while(font_heigh)
+                    {
+                        X11DRV_XRender_ExtTextOut(physDev, x + (int)(font_heigh * 0.25), 
+                                y + (int)(font_heigh * 0.5), 
+                                flags, lprect, wstr, count, lpDx);
+                        X11DRV_XRender_ExtTextOut(physDev, x - (int)(font_heigh * 0.25), 
+                                y - (int)(font_heigh * 0.5), 
+                                flags, lprect, wstr, count, lpDx);
+                        /* prettier
+                           X11DRV_XRender_ExtTextOut(physDev, x + (int)(font_heigh * 0.25), y, 
+                           flags, lprect, wstr, count, lpDx);
+                           X11DRV_XRender_ExtTextOut(physDev, x - (int)(font_heigh * 0.25), y, 
+                           flags, lprect, wstr, count, lpDx);
+                           X11DRV_XRender_ExtTextOut(physDev, x, y + (int)(font_heigh * 0.5), 
+                           flags, lprect, wstr, count, lpDx);
+                           X11DRV_XRender_ExtTextOut(physDev, x, y - (int)(font_heigh * 0.5), 
+                           flags, lprect, wstr, count, lpDx);
+                           */
+                        --font_heigh;
+                    }
+                }
+            } /* end flag2 */
+        } /* if rotate */
+        return X11DRV_XRender_ExtTextOut(physDev, x, y, flags, lprect, wstr, count, lpDx);
+    }
+#endif
 
     if (!X11DRV_SetupGCForText( physDev )) return TRUE;
 
diff -urN wine-1.0/dlls/winex11.drv/xdnd.c wine-1.0-uk/dlls/winex11.drv/xdnd.c
--- wine-1.0/dlls/winex11.drv/xdnd.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/dlls/winex11.drv/xdnd.c	2009-08-18 16:11:13.000000000 +0800
@@ -393,7 +393,11 @@
 
         if (path)
         {
+#ifndef UNIFIED_KERNEL /* modify for dragging file with Chinese file name */
             int pathSize = strlenW(path) + 1;
+#else
+            int pathSize = WideCharToMultiByte(CP_ACP, 0, path, -1, NULL, 0, 0, 0);
+#endif
             if (pathSize > capacity-size)
             {
                 capacity = 2*capacity + pathSize;
diff -urN wine-1.0/include/handle.h wine-1.0-uk/include/handle.h
--- wine-1.0/include/handle.h	1970-01-01 08:00:00.000000000 +0800
+++ wine-1.0-uk/include/handle.h	2009-08-19 12:44:28.000000000 +0800
@@ -0,0 +1,59 @@
+/*
+ * handle.h
+ *
+ * Copyright (C) 2006  Insigme Co., Ltd
+ *
+ * This software has been developed while working on the Linux Unified Kernel
+ * project (http://linux.insigma.com.cn) in the Insigma Research Institute,  
+ * which is a subdivision of Insigma Co., Ltd (http://www.insigma.com.cn).
+ * 
+ * The project is sponsored by Insigma Co., Ltd.
+ *
+ * The authors can be reached at linux@insigma.com.cn.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation; either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Revision History:
+ *   Jan 2006 - Created.
+ */
+ 
+/*
+ * handle.h: We use Unified Kernel handles to make it compatible with Wine's 
+ *           operations.
+ */
+
+#ifndef __UK_HANDLE_H
+#define __UK_HANDLE_H
+
+#ifdef UNIFIED_KERNEL
+#include "wine/list.h"
+
+/* 
+ * if the handle value greater than (1<<15), it will fault when someone 
+ * call it
+ */
+#define UK_HANDLE_FLAG (1 << 15)
+#define HANDLE_TO_UK_HANDLE(handle) \
+    (HANDLE)((ULONG_PTR)(handle) | UK_HANDLE_FLAG)
+#define UK_HANDLE_TO_HANDLE(handle)             \
+    (HANDLE)((ULONG_PTR)(handle) & ~UK_HANDLE_FLAG)
+
+#define IS_UK_HANDLE(handle) \
+    ((ULONG_PTR)(handle) & UK_HANDLE_FLAG)
+
+struct handle_pair
+{
+    struct list entry;
+    HANDLE uk_handle;
+    HANDLE wine_handle;
+};
+
+struct handle_pair* search_handle_pair(HANDLE uk_handle);
+void delete_handle_pair(struct handle_pair* pair);
+int store_handle_pair(HANDLE uk_handle, HANDLE wine_handle);
+#endif /* UNIFIED_KERNEL */
+
+#endif /* __UK_HANDLE_H */
diff -urN wine-1.0/include/winbase.h wine-1.0-uk/include/winbase.h
--- wine-1.0/include/winbase.h	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/include/winbase.h	2009-08-18 16:11:13.000000000 +0800
@@ -1444,7 +1444,11 @@
 WINADVAPI  BOOL        WINAPI EqualPrefixSid(PSID,PSID);
 WINBASEAPI DWORD       WINAPI EraseTape(HANDLE,DWORD,BOOL);
 WINBASEAPI VOID DECLSPEC_NORETURN WINAPI ExitProcess(DWORD);
+#ifndef UNIFIED_KERNEL
 WINBASEAPI VOID DECLSPEC_NORETURN WINAPI ExitThread(DWORD);
+#else
+VOID        WINAPI ExitThread(DWORD);
+#endif
 WINBASEAPI DWORD       WINAPI ExpandEnvironmentStringsA(LPCSTR,LPSTR,DWORD);
 WINBASEAPI DWORD       WINAPI ExpandEnvironmentStringsW(LPCWSTR,LPWSTR,DWORD);
 #define                       ExpandEnvironmentStrings WINELIB_NAME_AW(ExpandEnvironmentStrings)
diff -urN wine-1.0/include/wine/server_protocol.h wine-1.0-uk/include/wine/server_protocol.h
--- wine-1.0/include/wine/server_protocol.h	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/include/wine/server_protocol.h	2009-08-18 16:11:13.000000000 +0800
@@ -488,6 +488,9 @@
     unsigned int attributes;
     int          suspend;
     int          request_fd;
+#ifdef UNIFIED_KERNEL
+    int		 tid;
+#endif
 };
 struct new_thread_reply
 {
@@ -541,6 +544,10 @@
     void*        ldt_copy;
     int          reply_fd;
     int          wait_fd;
+#ifdef UNIFIED_KERNEL
+    int		 pid;
+    int		 tid;
+#endif
 };
 struct init_thread_reply
 {
@@ -1070,6 +1077,7 @@
     int          removable;
     unsigned int access;
     unsigned int options;
+	int          fd;
 };
 enum server_fd_type
 {
diff -urN wine-1.0/include/wingdi.h wine-1.0-uk/include/wingdi.h
--- wine-1.0/include/wingdi.h	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/include/wingdi.h	2009-08-18 16:11:13.000000000 +0800
@@ -1269,6 +1269,11 @@
 #define ETO_NUMERICSLATIN   0x0800
 #define ETO_IGNORELANGUAGE  0x1000
 #define ETO_PDY             0x2000
+#ifdef UNIFIED_KERNEL
+#define ETO_BOLD_FLAG1		0x4000
+#define ETO_BOLD_FLAG2		0x8000
+#define ETO_ROTATE		0x0008
+#endif
 
 #define ASPECT_FILTERING    0x0001
 
@@ -3398,7 +3403,12 @@
 WINGDIAPI BOOL        WINAPI ExtFloodFill(HDC,INT,INT,COLORREF,UINT);
 WINGDIAPI INT         WINAPI ExtSelectClipRgn(HDC,HRGN,INT);
 WINGDIAPI BOOL        WINAPI ExtTextOutA(HDC,INT,INT,UINT,const RECT*,LPCSTR,UINT,const INT*);
+#ifndef UNIFIED_KERNEL
 WINGDIAPI BOOL        WINAPI ExtTextOutW(HDC,INT,INT,UINT,const RECT*,LPCWSTR,UINT,const INT*);
+#else
+BOOL      WINAPI ExtTextOutW(HDC,INT,INT,UINT,const RECT*,
+                                 LPWSTR,UINT,const INT*);
+#endif
 #define                      ExtTextOut WINELIB_NAME_AW(ExtTextOut)
 WINGDIAPI BOOL        WINAPI FillPath(HDC);
 WINGDIAPI BOOL        WINAPI FillRgn(HDC,HRGN,HBRUSH);
diff -urN wine-1.0/include/winternl.h wine-1.0-uk/include/winternl.h
--- wine-1.0/include/winternl.h	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/include/winternl.h	2009-08-18 16:11:13.000000000 +0800
@@ -2158,7 +2158,11 @@
 NTSYSAPI BOOL      WINAPI RtlEqualSid(PSID,PSID);
 NTSYSAPI BOOLEAN   WINAPI RtlEqualString(const STRING*,const STRING*,BOOLEAN);
 NTSYSAPI BOOLEAN   WINAPI RtlEqualUnicodeString(const UNICODE_STRING*,const UNICODE_STRING*,BOOLEAN);
+#ifndef UNIFIED_KERNEL
 NTSYSAPI void      DECLSPEC_NORETURN WINAPI RtlExitUserThread(ULONG);
+#else
+void	  WINAPI RtlExitUserThread(ULONG);
+#endif
 NTSYSAPI NTSTATUS  WINAPI RtlExpandEnvironmentStrings_U(PCWSTR, const UNICODE_STRING*, UNICODE_STRING*, ULONG*);
 NTSYSAPI LONGLONG  WINAPI RtlExtendedMagicDivide(LONGLONG,LONGLONG,INT);
 NTSYSAPI LONGLONG  WINAPI RtlExtendedIntegerMultiply(LONGLONG,INT);
diff -urN wine-1.0/libs/wine/config.c wine-1.0-uk/libs/wine/config.c
--- wine-1.0/libs/wine/config.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/libs/wine/config.c	2009-08-18 16:11:13.000000000 +0800
@@ -424,6 +424,7 @@
 #ifdef linux
     if (use_preloader)
     {
+#ifndef UNIFIED_KERNEL_EXESO
         static const char preloader[] = "wine-preloader";
         char *p, *full_name;
         char **last_arg = argv, **new_argv;
@@ -444,6 +445,40 @@
         free( new_argv );
         free( full_name );
         return;
+#else
+        char *p;
+        char **last_arg = argv, **new_argv;
+
+        /* make a copy of argv */
+        while (*last_arg) last_arg++;
+        new_argv = xmalloc( (last_arg - argv) * sizeof(*argv) );
+        if(!new_argv)
+            return;
+        memcpy( new_argv, argv + 1, (last_arg - argv) * sizeof(*argv) );
+
+        get_dlldir((const char **)&p);
+        if(strchr(new_argv[0], '/') == NULL) {
+            new_argv[0] = xmalloc(strlen(p) + strlen(argv[1]) + 1 + 1 + 7);
+            if(new_argv[0] == NULL) {
+                free(new_argv);
+                return;
+            }
+            strcpy(new_argv[0], p);
+            strcat(new_argv[0], "/");
+            strcat(new_argv[0], argv[1]);
+            if((p = strrchr(argv[1], '.')) == NULL)
+                strcat(new_argv[0], ".exe.so");
+            else {
+                if(strcmp(p, ".exe") == 0) {
+                    strcat(new_argv[0], ".so");
+                }
+            }
+        }
+
+        execv( new_argv[0], new_argv );
+        free( new_argv );
+        return;
+#endif
     }
 #endif
     execv( argv[0], argv );
diff -urN wine-1.0/libs/wine/debug.c wine-1.0-uk/libs/wine/debug.c
--- wine-1.0/libs/wine/debug.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/libs/wine/debug.c	2009-08-18 16:11:13.000000000 +0800
@@ -119,7 +119,11 @@
 }
 
 /* parse a set of debugging option specifications and add them to the option list */
+#ifndef UNIFIED_KERNEL
 static void parse_options( const char *str )
+#else
+void parse_options( const char *str )
+#endif
 {
     char *opt, *next, *options;
     unsigned int i;
@@ -169,7 +173,11 @@
 
 
 /* print the usage message */
+#ifndef UNIFIED_KERNEL
 static void debug_usage(void)
+#else
+void debug_usage(void)
+#endif
 {
     static const char usage[] =
         "Syntax of the WINEDEBUG variable:\n"
diff -urN wine-1.0/libs/wine/loader.c wine-1.0-uk/libs/wine/loader.c
--- wine-1.0/libs/wine/loader.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/libs/wine/loader.c	2009-08-18 16:11:13.000000000 +0800
@@ -91,7 +91,11 @@
 extern const char *get_dlldir( const char **default_dlldir );
 
 /* build the dll load path from the WINEDLLPATH variable */
+#ifndef UNIFIED_KERNEL
 static void build_dll_path(void)
+#else
+void build_dll_path(void)
+#endif
 {
     int len, count = 0;
     char *p, *path = getenv( "WINEDLLPATH" );
@@ -321,7 +325,11 @@
 
 
 /* map a builtin dll in memory and fixup RVAs */
+#ifndef UNIFIED_KERNEL_EXESO
 static void *map_dll( const IMAGE_NT_HEADERS *nt_descr )
+#else
+void *map_dll( const IMAGE_NT_HEADERS *nt_descr )
+#endif
 {
 #ifdef HAVE_MMAP
     IMAGE_DATA_DIRECTORY *dir;
@@ -807,3 +815,10 @@
     return 1;
 #endif
 }
+
+#ifdef UNIFIED_KERNEL_EXESO
+IMAGE_NT_HEADERS **get_main_exe_ptr()
+{
+    return (IMAGE_NT_HEADERS **)&main_exe;
+}
+#endif
diff -urN wine-1.0/libs/wine/Makefile.in wine-1.0-uk/libs/wine/Makefile.in
--- wine-1.0/libs/wine/Makefile.in	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/libs/wine/Makefile.in	2009-08-18 16:11:13.000000000 +0800
@@ -7,7 +7,8 @@
 MODULE    = libwine.$(LIBEXT)
 VERSCRIPT = $(SRCDIR)/wine.map
 EXTRALIBS = $(LIBPORT) @LIBDL@ @CRTLIBS@
-DEFS      = -D__WINESRC__ -DWINE_UNICODE_API=""
+DEFS      = -D__WINESRC__ -DWINE_UNICODE_API="" \
+	    -DUNIFIED_KERNEL -DUNIFIED_KERNEL_EXESO
 
 VERSION   = 1.0
 SOVERSION = 1
diff -urN wine-1.0/libs/wine/mmap.c wine-1.0-uk/libs/wine/mmap.c
--- wine-1.0/libs/wine/mmap.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/libs/wine/mmap.c	2009-08-18 16:11:13.000000000 +0800
@@ -312,6 +312,12 @@
     wine_mmap_add_reserved_area( NULL, dos_area_size );
 }
 
+#ifdef UNIFIED_KERNEL
+void uk_reserve_dos_area(void)
+{
+    reserve_dos_area();
+}
+#endif
 
 /***********************************************************************
  *           mmap_init
diff -urN wine-1.0/libs/wine/wine.map wine-1.0-uk/libs/wine/wine.map
--- wine-1.0/libs/wine/wine.map	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/libs/wine/wine.map	2009-08-18 16:11:13.000000000 +0800
@@ -117,6 +117,13 @@
     wine_utf8_mbstowcs;
     wine_utf8_wcstombs;
     wine_wctype_table;
+    build_dll_path;
+    debug_usage;
+    parse_options;
+    get_dlldir;
+    get_main_exe_ptr;
+    map_dll;
+    uk_reserve_dos_area;
 
   local: *;
 };
diff -urN wine-1.0/loader/glibc.c wine-1.0-uk/loader/glibc.c
--- wine-1.0/loader/glibc.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/loader/glibc.c	2009-08-18 16:11:13.000000000 +0800
@@ -112,6 +112,32 @@
 }
 
 
+#ifdef UNIFIED_KERNEL
+static void check_command_line( int argc, char *argv[] )
+{
+    static const char usage[] =
+        "Usage: wine PROGRAM [ARGUMENTS...]   Run the specified program\n"
+        "       wine --help                   Display this help and exit\n"
+        "       wine --version                Output version information and exit";
+
+    if (argc <= 1)
+    {
+        fprintf( stderr, "%s\n", usage );
+        exit(1);
+    }
+    if (!strcmp( argv[1], "--help" ))
+    {
+        printf( "%s\n", usage);
+        exit(0);
+    }
+    if (!strcmp( argv[1], "--version" ))
+    {
+        printf( "%s\n", wine_get_build_id() );
+        exit(0);
+    }
+}
+#endif
+
 /**********************************************************************
  *           main
  */
@@ -121,6 +147,9 @@
     const char *threads = get_threading();
     const char *new_argv0 = build_new_path( argv[0], threads );
 
+#ifdef UNIFIED_KERNEL
+    check_command_line( argc, argv );
+#endif
     wine_init_argv0_path( new_argv0 );
 
     /* set the address space limit before starting the preloader */
diff -urN wine-1.0/loader/Makefile.in wine-1.0-uk/loader/Makefile.in
--- wine-1.0/loader/Makefile.in	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/loader/Makefile.in	2009-08-18 16:11:13.000000000 +0800
@@ -1,3 +1,4 @@
+DEFS      = -DUNIFIED_KERNEL
 TOPSRCDIR = @top_srcdir@
 TOPOBJDIR = ..
 SRCDIR    = @srcdir@
diff -urN wine-1.0/programs/explorer/explorer.c wine-1.0-uk/programs/explorer/explorer.c
--- wine-1.0/programs/explorer/explorer.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/programs/explorer/explorer.c	2009-08-18 16:11:13.000000000 +0800
@@ -135,8 +135,23 @@
     }
     if (p2 && *p2)
     {
+#ifndef UNIFIED_KERNEL /* resolve the problem that path with blank can't be opened */
         /* left over command line is generally the path to be opened */
         CopyPathString(parameters->root,p2);
+#else
+        LPWSTR quotationW = NULL;
+        int len = strlenW(p2);
+
+        quotationW = HeapAlloc(GetProcessHeap(), 0, (len + 3) * sizeof(WCHAR));
+        if (quotationW) {
+            quotationW[0] = '\"';
+            strcpyW(&quotationW[1], p2);
+            quotationW[len + 1] = '\"';
+            quotationW[len + 2] = 0;
+            CopyPathString(parameters->root,quotationW);
+            HeapFree(GetProcessHeap(), 0, quotationW);
+        }
+#endif
     }
 }
 
diff -urN wine-1.0/programs/Makeprog.rules.in wine-1.0-uk/programs/Makeprog.rules.in
--- wine-1.0/programs/Makeprog.rules.in	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/programs/Makeprog.rules.in	2009-08-18 16:11:13.000000000 +0800
@@ -10,7 +10,7 @@
 #
 
 DLLFLAGS    = @DLLFLAGS@
-DEFS        = $(EXTRADEFS)
+DEFS        = $(EXTRADEFS) -DUNIFIED_KERNEL
 ALL_LIBS    = $(DELAYIMPORTS:%=-l%) $(IMPORTS:%=-l%) $(EXTRALIBS) $(LIBPORT) $(LDFLAGS) $(LIBS)
 BASEMODULE  = $(MODULE:.exe=)
 RUNTESTFLAGS= -q -P wine -T $(TOPOBJDIR)
diff -urN wine-1.0/programs/services/services.c wine-1.0-uk/programs/services/services.c
--- wine-1.0/programs/services/services.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/programs/services/services.c	2009-08-18 16:11:13.000000000 +0800
@@ -533,6 +533,7 @@
     return name;
 }
 
+#ifndef UNIFIED_KERNEL
 static DWORD service_start_process(struct service_entry *service_entry, HANDLE *process)
 {
     PROCESS_INFORMATION pi;
@@ -675,12 +676,15 @@
 
     return r;
 }
+#endif
 
 DWORD service_start(struct service_entry *service, DWORD service_argc, LPCWSTR *service_argv)
 {
     DWORD err;
     LPWSTR name;
+#ifndef UNIFIED_KERNEL
     HANDLE process_handle = NULL;
+#endif
 
     err = scmdatabase_lock_startup(service->db);
     if (err != ERROR_SUCCESS)
@@ -709,6 +713,7 @@
         return GetLastError();
     }
 
+#ifndef UNIFIED_KERNEL
     err = service_start_process(service, &process_handle);
 
     if (err == ERROR_SUCCESS)
@@ -722,6 +727,7 @@
 
     if (process_handle)
         CloseHandle(process_handle);
+#endif
 
     ReleaseMutex(service->control_mutex);
     scmdatabase_unlock_startup(service->db);
diff -urN wine-1.0/programs/winefile/winefile.c wine-1.0-uk/programs/winefile/winefile.c
--- wine-1.0/programs/winefile/winefile.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/programs/winefile/winefile.c	2009-08-18 16:11:13.000000000 +0800
@@ -34,6 +34,10 @@
 #include "winefile.h"
 #include "resource.h"
 
+#ifdef UNIFIED_KERNEL
+#include "wine/library.h"
+#endif
+
 #ifdef _NO_EXTENSIONS
 #undef _LEFT_FILES
 #endif
@@ -3782,6 +3786,11 @@
 static void set_curdir(ChildWnd* child, Entry* entry, int idx, HWND hwnd)
 {
 	TCHAR path[MAX_PATH];
+#ifdef UNIFIED_KERNEL
+    const char *config_dir = wine_get_config_dir();
+    char cmdline[MAX_PATH], ansi_path[MAX_PATH];
+    int i;
+#endif
 
 	if (!entry)
 		return;
@@ -3807,6 +3816,22 @@
 	if (path[0])
 		if (SetCurrentDirectory(path))
 			set_space_status();
+
+#ifdef UNIFIED_KERNEL
+    strcpy(cmdline, config_dir);
+    strcat(cmdline, "/dosdevices/");
+    WideCharToMultiByte(CP_UNIXCP, 0, path, -1, ansi_path, sizeof(ansi_path), NULL, NULL);
+    if (ansi_path[0] >= 0x0041 && ansi_path[0] <= 0x005a)
+        ansi_path[0] += 32;
+    for (i = 0; i < strlen(ansi_path); i++) {
+        if (ansi_path[i] == '\\')
+            ansi_path[i] = '/';
+    }
+    strcat(cmdline, ansi_path);
+    if (execl("/usr/bin/kfmclient", "kfmclient", "exec", cmdline, (char *)0) < 0) {
+        execl("/usr/bin/nautilus", "nautilus", cmdline, (char *)0);
+    }
+#endif
 }
 
 
diff -urN wine-1.0/programs/winemenubuilder/winemenubuilder.c wine-1.0-uk/programs/winemenubuilder/winemenubuilder.c
--- wine-1.0/programs/winemenubuilder/winemenubuilder.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/programs/winemenubuilder/winemenubuilder.c	2009-08-18 16:11:13.000000000 +0800
@@ -1180,7 +1180,12 @@
     }
 
     /* escape the path and parameters */
+#ifndef UNIFIED_KERNEL
     escaped_path = escape(szPath);
+#else
+    /* convert the path passed to wineshelllink into unix format */
+    escaped_path = wine_get_unix_file_name( szPath );
+#endif
     escaped_args = escape(szArgs);
     escaped_description = escape(szDescription);
 
diff -urN wine-1.0/server/Makefile.in wine-1.0-uk/server/Makefile.in
--- wine-1.0/server/Makefile.in	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/server/Makefile.in	2009-08-18 16:11:13.000000000 +0800
@@ -1,4 +1,4 @@
-DEFS      = -D__WINESRC__
+DEFS      = -D__WINESRC__ -DUNIFIED_KERNEL
 TOPSRCDIR = @top_srcdir@
 TOPOBJDIR = ..
 SRCDIR    = @srcdir@
diff -urN wine-1.0/server/process.c wine-1.0-uk/server/process.c
--- wine-1.0/server/process.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/server/process.c	2009-08-18 16:11:13.000000000 +0800
@@ -142,6 +142,12 @@
     unsigned int next;  /* next free entry */
 };
 
+#ifdef UNIFIED_KERNEL
+#define PTID_RESERVE_OFFSET 32
+#define PTID_TO_INDEX(id) ((id >> 2) - PTID_RESERVE_OFFSET)
+#define INDEX_TO_PTID(index) ((index + PTID_RESERVE_OFFSET) << 2)
+#endif
+
 static struct ptid_entry *ptid_entries;     /* array of ptid entries */
 static unsigned int used_ptid_entries;      /* number of entries in use */
 static unsigned int alloc_ptid_entries;     /* number of allocated entries */
@@ -188,9 +194,42 @@
     return id;
 }
 
+#ifdef UNIFIED_KERNEL
+/*
+ * store_ptid:
+ * Store the pid/tid we get from the client.
+ * - The only thing we should care is that
+ * - a pid/tid is created linearly.
+ */
+int store_ptid(unsigned int id, void *ptr)
+{
+    struct ptid_entry *entry;
+    unsigned int index = PTID_TO_INDEX(id);
+
+    if (index < alloc_ptid_entries)
+        entry = &ptid_entries[index];
+    else
+    {
+        unsigned int count = alloc_ptid_entries + (alloc_ptid_entries / 2);
+        if (!count)
+            count = 64;
+        if (!(entry = realloc(ptid_entries, count * sizeof(*entry))))
+            return 0;
+
+        ptid_entries = entry;
+        alloc_ptid_entries = count;
+        entry = &ptid_entries[index];
+    }
+    used_ptid_entries++;
+    entry->ptr = ptr;
+    return index;
+}
+#endif
+
 /* free a process or thread id */
 void free_ptid( unsigned int id )
 {
+#ifndef UNIFIED_KERNEL
     struct ptid_entry *entry = &ptid_entries[id - PTID_OFFSET];
 
     entry->ptr  = NULL;
@@ -201,14 +240,28 @@
     else next_free_ptid = id;
 
     last_free_ptid = id;
+#else
+    struct ptid_entry *entry = &ptid_entries[PTID_TO_INDEX(id)];
+
+    entry->ptr  = NULL;
+    entry->next = 0;
+    used_ptid_entries--;
+#endif
 }
 
 /* retrieve the pointer corresponding to a process or thread id */
 void *get_ptid_entry( unsigned int id )
 {
+#ifndef UNIFIED_KERNEL
     if (id < PTID_OFFSET) return NULL;
     if (id - PTID_OFFSET >= used_ptid_entries) return NULL;
     return ptid_entries[id - PTID_OFFSET].ptr;
+#else
+    int index = PTID_TO_INDEX(id);
+    if ((id % 4) || (index <= 0))
+        return NULL;
+    return ptid_entries[index].ptr;
+#endif
 }
 
 /* return the main thread of the process */
@@ -346,11 +399,15 @@
     process->end_time = 0;
     list_add_tail( &process_list, &process->entry );
 
+#ifndef UNIFIED_KERNEL
     if (!(process->id = process->group_id = alloc_ptid( process )))
     {
         close( fd );
         goto error;
     }
+#else
+    process->id = process->group_id = 0;
+#endif
     if (!(process->msg_fd = create_anonymous_fd( &process_fd_ops, fd, &process->obj, 0 ))) goto error;
 
     /* create the handle table */
@@ -426,7 +483,9 @@
     list_remove( &process->entry );
     if (process->idle_event) release_object( process->idle_event );
     if (process->queue) release_object( process->queue );
+#ifndef UNIFIED_KERNEL
     if (process->id) free_ptid( process->id );
+#endif
     if (process->token) release_object( process->token );
 }
 
@@ -594,6 +653,9 @@
         if (thread == skip) break;
         kill_thread( thread, 1 );
     }
+#ifdef UNIFIED_KERNEL
+    if (process->id) free_ptid( process->id );
+#endif
     release_object( process );
 }
 
@@ -747,6 +809,9 @@
             struct thread *thread = LIST_ENTRY( ptr, struct thread, proc_entry );
             kill_thread( thread, 0 );
         }
+#ifdef UNIFIED_KERNEL
+        if (process->id) free_ptid( process->id );
+#endif
         release_object( process );
     }
 }
@@ -970,8 +1035,10 @@
 
     info->process = (struct process *)grab_object( process );
     reply->info = alloc_handle( current->process, info, SYNCHRONIZE, 0 );
+#ifndef UNIFIED_KERNEL
     reply->pid = get_process_id( process );
     reply->tid = get_thread_id( thread );
+#endif
     reply->phandle = alloc_handle( parent, process, req->process_access, req->process_attr );
     reply->thandle = alloc_handle( parent, thread, req->thread_access, req->thread_attr );
 
@@ -1042,7 +1109,9 @@
     set_process_startup_state( process, STARTUP_DONE );
 
     if (req->gui) process->idle_event = create_event( NULL, NULL, 0, 1, 0, NULL );
+#ifndef UNIFIED_KERNEL
     if (current->suspend + process->suspend > 0) stop_thread( current );
+#endif
     if (process->debugger) set_process_debug_flag( process, 1 );
 }
 
diff -urN wine-1.0/server/thread.c wine-1.0-uk/server/thread.c
--- wine-1.0/server/thread.c	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/server/thread.c	2009-08-19 11:05:05.000000000 +0800
@@ -50,6 +50,10 @@
 #include "security.h"
 
 
+#ifdef UNIFIED_KERNEL
+extern int store_ptid(unsigned int id, void *ptr);
+#endif
+
 /* thread queues */
 
 struct thread_wait
@@ -208,11 +212,15 @@
 
     list_add_head( &thread_list, &thread->entry );
 
+#ifndef UNIFIED_KERNEL
     if (!(thread->id = alloc_ptid( thread )))
     {
         release_object( thread );
         return NULL;
     }
+#else
+    thread->id = 0;
+#endif
     if (!(thread->request_fd = create_anonymous_fd( &thread_fd_ops, fd, &thread->obj, 0 )))
     {
         release_object( thread );
@@ -281,7 +289,9 @@
     list_remove( &thread->entry );
     cleanup_thread( thread );
     release_object( thread->process );
+#ifndef UNIFIED_KERNEL
     if (thread->id) free_ptid( thread->id );
+#endif
     if (thread->token) release_object( thread->token );
 }
 
@@ -432,7 +442,11 @@
     int old_count = thread->suspend;
     if (thread->suspend < MAXIMUM_SUSPEND_COUNT)
     {
+#ifndef UNIFIED_KERNEL
         if (!(thread->process->suspend + thread->suspend++)) stop_thread( thread );
+#else
+        thread->suspend++;
+#endif
     }
     else set_error( STATUS_SUSPEND_COUNT_EXCEEDED );
     return old_count;
@@ -444,7 +458,11 @@
     int old_count = thread->suspend;
     if (thread->suspend > 0)
     {
+#ifndef UNIFIED_KERNEL
         if (!(--thread->suspend + thread->process->suspend)) wake_thread( thread );
+#else
+        thread->suspend--;
+#endif
     }
     return old_count;
 }
@@ -916,17 +934,24 @@
     if (thread->wait)
     {
         while (thread->wait) end_wait( thread );
+#ifndef UNIFIED_KERNEL
         send_thread_wakeup( thread, NULL, STATUS_PENDING );
         /* if it is waiting on the socket, we don't need to send a SIGQUIT */
         violent_death = 0;
+#endif
     }
     kill_console_processes( thread, 0 );
+#ifndef UNIFIED_KERNEL
     debug_exit_thread( thread );
     abandon_mutexes( thread );
     wake_up( &thread->obj, 0 );
     if (violent_death) send_thread_signal( thread, SIGQUIT );
+#endif
     cleanup_thread( thread );
     remove_process_thread( thread->process, thread );
+#ifdef UNIFIED_KERNEL
+    if (thread->id && violent_death) free_ptid( thread->id );
+#endif
     release_object( thread );
 }
 
@@ -995,6 +1020,12 @@
 
     if ((thread = create_thread( request_fd, current->process )))
     {
+#ifdef UNIFIED_KERNEL
+        if(req->tid){
+            thread->id = req->tid;
+            store_ptid(thread->id, thread);
+        }
+#endif
         if (req->suspend) thread->suspend++;
         reply->tid = get_thread_id( thread );
         if ((reply->handle = alloc_handle( current->process, thread, req->access, req->attributes )))
@@ -1042,6 +1073,17 @@
     current->unix_pid = req->unix_pid;
     current->unix_tid = req->unix_tid;
     current->teb      = req->teb;
+#ifdef UNIFIED_KERNEL
+    /* We use the pid/tid allocated from kernel, and store it in the server */
+    if (!(current->id) && !(process->id)) {
+        /* If this request doesn't come from the procedure of process creating,
+         * it will never be here. */
+        process->group_id = process->id = req->pid;
+        current->id       = req->tid;
+        store_ptid(process->id, process);
+        store_ptid(current->id, current);
+    }
+#endif
 
     if (!process->peb)  /* first thread, initialize the process too */
     {
@@ -1054,7 +1096,9 @@
     {
         if (process->unix_pid != current->unix_pid)
             process->unix_pid = -1;  /* can happen with linuxthreads */
+#ifndef UNIFIED_KERNEL
         if (current->suspend + process->suspend > 0) stop_thread( current );
+#endif
         generate_debug_event( current, CREATE_THREAD_DEBUG_EVENT, req->entry );
     }
     debug_level = max( debug_level, req->debug_level );
@@ -1085,6 +1129,9 @@
         {
             reply->self = 1;
             reply->last = (thread->process->running_threads == 1);
+#ifdef UNIFIED_KERNEL
+            if (thread->id) free_ptid( thread->id );
+#endif
         }
         release_object( thread );
     }
diff -urN wine-1.0/tools/wineshelllink wine-1.0-uk/tools/wineshelllink
--- wine-1.0/tools/wineshelllink	2008-06-17 22:07:31.000000000 +0800
+++ wine-1.0-uk/tools/wineshelllink	2009-08-18 16:11:13.000000000 +0800
@@ -87,7 +87,7 @@
     cat <<EOF
 [Desktop Entry]
 Name=$linkname
-Exec=env WINEPREFIX="${WINEPREFIX:-$HOME/.wine}" wine "$path" $args
+Exec="$path" $args
 Type=Application
 StartupWMClass=Wine
 EOF
